///////////////////////////////////////////////////////////////////////////////
// SixAxisArticulatedTrafo.cpp
#include "TcPch.h"
#pragma hdrstop

#include "SixAxisArticulatedTrafo.h"
#include "TC_DriverVersion.h"

#include <cmath>
#include <vector>
#include <array>

#define M_PI 3.14159265358979323846

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CSixAxisArticulatedTrafo
BEGIN_INTERFACE_MAP(CSixAxisArticulatedTrafo)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcNcTrafo, ITcNcTrafo)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_IPERSIST_LIB(CSixAxisArticulatedTrafo, VID_TC_Driver, CID_TC_DriverCSixAxisArticulatedTrafo)
IMPLEMENT_ITCOMOBJECT(CSixAxisArticulatedTrafo)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CSixAxisArticulatedTrafo)
IMPLEMENT_ITCADI(CSixAxisArticulatedTrafo)
IMPLEMENT_ITCWATCHSOURCE(CSixAxisArticulatedTrafo)

///////////////////////////////////////////////////////////////////////////////
// Set parameters of CSixAxisArticulatedTrafo 
BEGIN_SETOBJPARA_MAP(CSixAxisArticulatedTrafo)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmLengthL1, m_ArmLengthL1)
	SETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmLengthL2, m_ArmLengthL2)
	SETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmLengthL3, m_ArmLengthL3)
	SETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmOffsetD1, m_ArmOffsetD1)
	SETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmOffsetD2, m_ArmOffsetD2)
	SETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmOffsetD3, m_ArmOffsetD3)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CSixAxisArticulatedTrafo 
BEGIN_GETOBJPARA_MAP(CSixAxisArticulatedTrafo)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmLengthL1, m_ArmLengthL1)
	GETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmLengthL2, m_ArmLengthL2)
	GETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmLengthL3, m_ArmLengthL3)
	GETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmOffsetD1, m_ArmOffsetD1)
	GETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmOffsetD2, m_ArmOffsetD2)
	GETOBJPARA_VALUE(PID_SixAxisArticulatedTrafoArmOffsetD3, m_ArmOffsetD3)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CSixAxisArticulatedTrafo
BEGIN_OBJPARAWATCH_MAP(CSixAxisArticulatedTrafo)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CSixAxisArticulatedTrafo
BEGIN_OBJDATAAREA_MAP(CSixAxisArticulatedTrafo)
///<AutoGeneratedContent id="ObjectDataAreaMap">
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
// Constructor
CSixAxisArticulatedTrafo::CSixAxisArticulatedTrafo() //: m_forwardNbrIn(6), m_forwardNbrOut(6)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_ArmLengthL1 = 0;
	m_ArmLengthL2 = 0;
	m_ArmLengthL3 = 0;
	m_ArmOffsetD1 = 0;
	m_ArmOffsetD2 = 0;
	m_ArmOffsetD3 = 0;
///</AutoGeneratedContent>
}

///////////////////////////////////////////////////////////////////////////////
// Destructor
CSixAxisArticulatedTrafo::~CSixAxisArticulatedTrafo() 
{
}

///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CSixAxisArticulatedTrafo)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CSixAxisArticulatedTrafo::SetObjStatePS(PTComInitDataHdr pInitData)
{
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CSixAxisArticulatedTrafo::SetObjStateSO()
{
	HRESULT hr = S_OK;
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CSixAxisArticulatedTrafo::SetObjStateOS()
{
	HRESULT hr = S_OK;
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CSixAxisArticulatedTrafo::SetObjStateSP()
{
	HRESULT hr = S_OK;
	return hr;
}



///////////// sudo kinematics code written by copilot /////////
// Define the DH parameters for the robot
struct DHParameter {
	double theta; // Joint angle
	double d;     // Link offset
	double a;     // Link length
	double alpha; // Link twist
};
// Function to create a transformation matrix from DH parameters
std::array<std::array<double, 4>, 4> dhToTransformationMatrix(const DHParameter& dh) {
	double ct = cos(dh.theta);
	double st = sin(dh.theta);
	double ca = cos(dh.alpha);
	double sa = sin(dh.alpha);

	return { {
		{ct, -st * ca, st * sa, dh.a * ct},
		{st, ct * ca, -ct * sa, dh.a * st},
		{0, sa, ca, dh.d},
		{0, 0, 0, 1}
	} };
}
// Function to multiply two 4x4 matrices
std::array<std::array<double, 4>, 4> multiplyMatrices(const std::array<std::array<double, 4>, 4>& A, const std::array<std::array<double, 4>, 4>& B) {
	std::array<std::array<double, 4>, 4> result = { 0 };

	for (int i = 0; i < 4; ++i) {
		for (int j = 0; j < 4; ++j) {
			for (int k = 0; k < 4; ++k) {
				result[i][j] += A[i][k] * B[k][j];
			}
		}
	}

	return result;
}
// Function to compute the forward kinematics
std::array<double, 3> forwardKinematics(const std::vector<DHParameter>& dhParams) {
	std::array<std::array<double, 4>, 4> T = { {
		{1, 0, 0, 0},
		{0, 1, 0, 0},
		{0, 0, 1, 0},
		{0, 0, 0, 1}
	} };

	for (const auto& dh : dhParams) {
		T = multiplyMatrices(T, dhToTransformationMatrix(dh));
	}

	return { T[0][3], T[1][3], T[2][3] };
}
// Function to compute the inverse kinematics
std::vector<double> inverseKinematics(const std::array<double, 3>& cartesianCoords, const std::vector<DHParameter>& dhParams) {
	std::vector<double> jointAngles(6, 0.0);

	// Example calculation for the first joint angle (theta1)
	jointAngles[0] = atan2(cartesianCoords[1], cartesianCoords[0]);

	// Additional calculations for other joint angles
	// This is a simplified example and may not cover all cases

	// Calculate theta2 to theta6
	// These calculations are highly dependent on the specific robot configuration
	// and require solving the inverse kinematics equations for each joint

	// Placeholder calculations for demonstration purposes
	jointAngles[1] = atan2(cartesianCoords[2], sqrt(cartesianCoords[0] * cartesianCoords[0] + cartesianCoords[1] * cartesianCoords[1]));
	jointAngles[2] = atan2(cartesianCoords[1], cartesianCoords[0]);
	jointAngles[3] = atan2(cartesianCoords[2], sqrt(cartesianCoords[0] * cartesianCoords[0] + cartesianCoords[1] * cartesianCoords[1]));
	jointAngles[4] = atan2(cartesianCoords[1], cartesianCoords[0]);
	jointAngles[5] = atan2(cartesianCoords[2], sqrt(cartesianCoords[0] * cartesianCoords[0] + cartesianCoords[1] * cartesianCoords[1]));

	return jointAngles;
}





///<AutoGeneratedContent id="ImplementationOf_ITcNcTrafo">
HRESULT CSixAxisArticulatedTrafo::Forward(TcNcTrafoParameter* p)
{
	double ACS[6];
	double MCS[6];

	std::memcpy(ACS, p->i, 5 * sizeof(double));

	switch (p->type) {
	case EcNcTrafoParameter_Invalid:
		break;
	case EcNcTrafoParameter_Base:
		break;
	case EcNcTrafoParameter_Ext:
		break;
	case EcNcTrafoParameter_ExtCnc:
		break;
	}
	/*
		EcNcTrafoParameter	type;
		ULONG						dim_i;		// dim of input vectors (i, d_i, dd_i)
		ULONG						dim_o;		// dim of output vectors (o, d_o, dd_o, torque)
		ULONG						dim_para;	// dim of additional parameter (para)

		const double*			i;				// input values parameter (dim_i)
		const double*			d_i;		
		const double*			dd_i;

		double*					o;				// output values parameter (dim_i)
		double*					d_o;
		double*					dd_o;

		double*					torque;
		const double*			para;			// additional parameter (dim_p)

		double					payload;		// weight in kg
		double					tool_len;	// actual tool length in [mm]
	*/




	// Example DH parameters for a 6-axis robot
	/*
		double m_ArmLengthL1;
		double m_ArmLengthL2;
		double m_ArmLengthL3;
		double m_ArmOffsetD1;
		double m_ArmOffsetD2;
		double m_ArmOffsetD3;
	*/
	std::vector<DHParameter> dhParams = {
		{0, 0.5, 0.25, M_PI / 2},
		{M_PI / 4, 0, 0.5, 0},
		{M_PI / 6, 0, 0.3, -M_PI / 2},
		{M_PI / 3, 0.2, 0, M_PI / 2},
		{M_PI / 4, 0, 0, -M_PI / 2},
		{M_PI / 6, 0.1, 0, 0}
	};

	auto cartesianCoords = forwardKinematics(dhParams);
	/*    
	std::cout << "Cartesian Coordinates: (" 
              << cartesianCoords[0] << ", " 
              << cartesianCoords[1] << ", " 
              << cartesianCoords[2] << ")" << std::endl;
	*/

	MCS[0] = 7.0;
	MCS[1] = 8.0;
	MCS[2] = 9.0;
	MCS[3] = 10.0;
	MCS[4] = 11.0;
	MCS[5] = 12.0;
	std::memcpy(p->o, MCS, 5 * sizeof(double));

	HRESULT hr = S_OK;
	return hr;
}

HRESULT CSixAxisArticulatedTrafo::Backward(TcNcTrafoParameter* p)
{
	double MCS[6];
	double ACS[6];

	std::memcpy(MCS, p->i, 5 * sizeof(double));

	// Example DH parameters for a 6-axis robot
	/*
		double m_ArmLengthL1;
		double m_ArmLengthL2;
		double m_ArmLengthL3;
		double m_ArmOffsetD1;
		double m_ArmOffsetD2;
		double m_ArmOffsetD3;
	*/
	std::vector<DHParameter> dhParams = {
		{0, 0.5, 0.25, M_PI / 2},
		{M_PI / 4, 0, 0.5, 0},
		{M_PI / 6, 0, 0.3, -M_PI / 2},
		{M_PI / 3, 0.2, 0, M_PI / 2},
		{M_PI / 4, 0, 0, -M_PI / 2},
		{M_PI / 6, 0.1, 0, 0}
	};

	std::array<double, 3> cartesianCoords;
	cartesianCoords[0] = 123.45;
	cartesianCoords[1] = 123.45;
	cartesianCoords[2] = 123.45;
	auto jointAngles = inverseKinematics(cartesianCoords, dhParams);
	/*
	std::cout << "Joint Angles: ";
	for (const auto& angle : jointAngles) {
		std::cout << angle << " ";
	}
	std::cout << std::endl;
	*/

	ACS[0] = 1.0;
	ACS[1] = 2.0;
	ACS[2] = 3.0;
	ACS[3] = 4.0;
	ACS[4] = 5.0;
	ACS[5] = 6.0;
	std::memcpy(p->o, ACS, 5 * sizeof(double));

	HRESULT hr = S_OK;
	return hr;
}

HRESULT CSixAxisArticulatedTrafo::TrafoSupported(TcNcTrafoParameter* p, bool fwd)
{
	HRESULT hr = S_OK;
	return hr;
}

HRESULT CSixAxisArticulatedTrafo::GetDimensions(ULONG* pFwdInput, ULONG* pFwdOutput)
{
	*pFwdInput = 4;
	*pFwdOutput = 4;

	HRESULT hr = S_OK;
	return hr;
}
///</AutoGeneratedContent>
