<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_JogProcessor" Id="{9ad0dd5a-e160-4345-8eee-ad9cf9bfb3eb}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_JogProcessor
VAR CONSTANT
	NumberOfAxes: UINT:=GVL.NumberOfAxes;
END_VAR
VAR_IN_OUT
	ACS: ARRAY[1..NumberOfAxes] OF AXIS_REF;
	MCS: ARRAY[1..NumberOfAxes] OF AXIS_REF;
	GroupHandler: FB_GroupHandler;
	//Controller: FB_Controller;
END_VAR
VAR_INPUT
	Enable: BOOL;
	Reset: BOOL;
	Velocity: LREAL := 0;
	Acceleration: LREAL := 0;
	Deceleration: LREAL := 0;
	Jerk: LREAL := 0;
    MaxAngularDistance: LREAL := 90.0;
	MaxLinearDistance: LREAL := 50.0;
// 	AccFactor: LREAL := 1.0;
// 	VelFactor: LREAL := 0.1;
// 	JerkFactor: LREAL := 1.0;
// 	TorqueFactor: LREAL := 1.0;
// 	JogForward: ARRAY[1..NumberOfAxes] OF BOOL;
// 	JogBackwards: ARRAY[1..NumberOfAxes] OF BOOL;
	CoordSystem: DUT_CoordSystem := DUT_CoordSystem.TCP;
	ABC_as_ACS: BOOL;
	StoredPositions: REFERENCE TO ARRAY[GVL.POS_ARR_BEG..GVL.POS_ARR_END] OF DUT_StoredPosition;
	VisionRegisters: REFERENCE TO ARRAY[GVL.VIS_ARR_BEG..GVL.VIS_ARR_END] OF DUT_VisionRegister;
	Flags: REFERENCE TO ARRAY[GVL.FLG_ARR_BEG..GVL.FLG_ARR_END] OF DUT_Flags;
END_VAR
VAR_OUTPUT
	Position: DUT_COORD_REF;
	Enabled: BOOL;
	Done: BOOL;
	Busy: BOOL;
	Error: BOOL;
	ErrorID: UDINT;
END_VAR
VAR
	_ResetRtrig: R_TRIG;
	_ErrorRtrig: R_TRIG;
	_EnableRtrig: R_TRIG;
	_EnableFtrig: F_TRIG;
	
	_SequenceMain: INT;
	_SequenceSetCoordTrans: INT;
	
	_MC_Jog: ARRAY[1..NumberOfAxes*2] OF MC_JOG;
	_MC_Halt: ARRAY[1..NumberOfAxes*2] OF MC_HALT;
	_Halt: ARRAY[1..NumberOfAxes*2] OF BOOL;
	_HaltFtrig: ARRAY[1..NumberOfAxes*2] OF F_Trig;
	_JogForward: ARRAY[1..NumberOfAxes] OF BOOL;
	_JogBackwards: ARRAY[1..NumberOfAxes] OF BOOL;
	_CoordSystem: DUT_CoordSystem := DUT_CoordSystem.TCP;
	
	_ControllerCenter: USINT:=128;
	_ControllerDeadZone: USINT:=40;
	
	_OffsetExist: ARRAY[0..GVL.MCS_POS_IDX-GVL.TCP_POS_IDX] OF BOOL;
	
	_MoveToPose: ARRAY[0..GVL.POSE_5_IDX-GVL.POSE_1_IDX] OF BOOL;
	_MoveCommandProcessor: MoveCmdProcessor;
	
	_i, _j, _k: UINT;
	_FirstScan: BOOL:=TRUE;
	
END_VAR

VAR CONSTANT
	STEP_DONE: 				INT := 1000;
	STEP_IDLE: 				INT := 0000;
	STEP_GROUP_ENABLE: 		INT := 0030;
	STEP_WAIT_ENABLE: 		INT := 0035;
	STEP_SET_KINEMATICS: 	INT := 0060;
	STEP_WAIT_KINEMATICS: 	INT := 0070;
	STEP_JOG:				INT := 0080;
	STEP_WAIT_JOG:			INT := 0090;
	STEP_GROUP_DISABLE: 	INT := 0100;
	STEP_WAIT_DISABLE: 		INT := 0110;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[_ResetRtrig(CLK:=Reset);

IF _FirstScan THEN
	//
END_IF

//
_M_HandleController();
_M_HandlePose();

//
_EnableFtrig(CLK:=Enable);
IF _EnableFtrig.Q THEN
	//;
END_IF
_EnableRtrig(CLK:=Enable);
IF _EnableRtrig.Q THEN
	//
END_IF

//
CASE _SequenceMain OF
	STEP_DONE: // done
		Busy := FALSE;
		Done := TRUE;
		_SequenceMain := STEP_IDLE;
		
	STEP_IDLE: // IDLE
		IF _EnableRtrig.Q THEN
			Busy := TRUE;
			Done := FALSE;
			_CoordSystem := CoordSystem;
			_M_CheckOffsets();
			_SequenceMain := STEP_GROUP_ENABLE;
		END_IF
		
	STEP_GROUP_ENABLE:
		IF GroupHandler.M_EnableGroup(_CoordSystem) THEN
			_SequenceMain := STEP_WAIT_ENABLE;
		ELSE
			_SequenceMain := STEP_DONE;
			Error := TRUE;
			ErrorID := GroupHandler.ErrorID;
		END_IF
		
	STEP_WAIT_ENABLE:
		// TODO add timeout timer here
		IF GroupHandler.P_GroupEnabled THEN
			_SequenceMain := STEP_WAIT_JOG;
		END_IF;
		
	STEP_WAIT_JOG: //
		FOR _k:= 1 TO NumberOfAxes DO
			IF _MC_Jog[_k].Error THEN
				Error := TRUE;
				ErrorID := _MC_Jog[_k].ErrorID;
			END_IF
		END_FOR
		IF _EnableFtrig.Q THEN
			_SequenceMain := STEP_GROUP_DISABLE;
			//_SequenceMain := STEP_DONE;
		END_IF
			
	STEP_GROUP_DISABLE:
		IF GroupHandler.M_DisableGroup() THEN
			_SequenceMain := STEP_WAIT_DISABLE;
		ELSE
			_SequenceMain := STEP_DONE;
			Error := TRUE;
			ErrorID := GroupHandler.ErrorID;
		END_IF
		
	STEP_WAIT_DISABLE:
		// TODO add timeouttimer here
		IF NOT GroupHandler.P_GroupEnabled THEN
			_SequenceMain := STEP_DONE;
		END_IF
	
END_CASE

//
IF _ResetRtrig.Q AND Error THEN
	Error := FALSE;
	ErrorID := 0;
	_SequenceMain := STEP_DONE;
	GroupHandler.M_ResetGroup();
	_MoveCommandProcessor.M_Home();
END_IF

// https://infosys.beckhoff.com/content/1033/tcplclib_tc2_mc2/70120459.html?id=7121036612998147748
FOR _k:= 1 TO NumberOfAxes DO
	_MC_Jog[_k](
		Axis:= ACS[_k], 
		JogForward:= SEL(_CoordSystem = DUT_CoordSystem.ACS, FALSE, _JogForward[_k]), 
		JogBackwards:= SEL(_CoordSystem = DUT_CoordSystem.ACS, FALSE, _JogBackwards[_k]), 
		Mode:= MC_JOGMODE_INCHING, // MC_JOGMODE_STANDARD_SLOW, MC_JOGMODE_STANDARD_FAST, MC_JOGMODE_CONTINUOUS, MC_JOGMODE_INCHING, MC_JOGMODE_INCHING_MODULO
		Position:= MaxAngularDistance, 
		Velocity:= Velocity, 
		Acceleration:= Acceleration, 
		Deceleration:= Deceleration, 
		Jerk:= Jerk, 
		Done=> , 
		Busy=> , 
		Active=> , 
		CommandAborted=> , 
		Error=> , 
		ErrorID=> );
	_MC_Jog[_k+NumberOfAxes](
		Axis:= MCS[_k], 
		JogForward:= SEL(_CoordSystem = DUT_CoordSystem.MCS, FALSE, _JogForward[_k]), 
		JogBackwards:= SEL(_CoordSystem = DUT_CoordSystem.MCS, FALSE, _JogBackwards[_k]), 
		Mode:= MC_JOGMODE_INCHING, // MC_JOGMODE_STANDARD_SLOW, MC_JOGMODE_STANDARD_FAST, MC_JOGMODE_CONTINUOUS, MC_JOGMODE_INCHING, MC_JOGMODE_INCHING_MODULO
		Position:= MaxLinearDistance, 
		Velocity:= Velocity, 
		Acceleration:= Acceleration, 
		Deceleration:= Deceleration, 
		Jerk:= Jerk, 
		Done=> , 
		Busy=> , 
		Active=> , 
		CommandAborted=> , 
		Error=> , 
		ErrorID=> );
END_FOR
FOR _k:= 1 TO NumberOfAxes DO
	IF _MC_Jog[_k].Error OR _MC_Jog[_k+NumberOfAxes].Error THEN
		//
	END_IF
END_FOR

//
FOR _k:= 1 TO NumberOfAxes DO
	_HaltFtrig[_k](CLK:=_JogForward[_k] OR _JogBackwards[_k]);
	IF _HaltFtrig[_k].Q THEN
		_Halt[_k]:=TRUE;
	END_IF
	_HaltFtrig[_k+NumberOfAxes](CLK:=_JogForward[_k] OR _JogBackwards[_k]);
	IF _HaltFtrig[_k+NumberOfAxes].Q THEN
		_Halt[_k+NumberOfAxes]:=TRUE;
	END_IF
END_FOR
FOR _k:= 1 TO NumberOfAxes DO
	_MC_Halt[_k](
		Axis:= ACS[_k], 
		Execute:= _Halt[_k], 
		Deceleration:= Deceleration, 
		Jerk:= Jerk, 
		BufferMode:= , 
		Options:= , 
		Done=> , 
		Busy=> , 
		Active=> , 
		CommandAborted=> , 
		Error=> , 
		ErrorID=> );
	_MC_Halt[_k+NumberOfAxes](
		Axis:= MCS[_k], 
		Execute:= _Halt[_k+NumberOfAxes], 
		Deceleration:= Deceleration, 
		Jerk:= Jerk, 
		BufferMode:= , 
		Options:= , 
		Done=> , 
		Busy=> , 
		Active=> , 
		CommandAborted=> , 
		Error=> , 
		ErrorID=> );
END_FOR
FOR _k:= 1 TO NumberOfAxes DO
	IF _MC_Halt[_k].Done OR _MC_Halt[_k].Error THEN
		_Halt[_k]:=FALSE;
	END_IF
	IF _MC_Halt[_k+NumberOfAxes].Done OR _MC_Halt[_k+NumberOfAxes].Error THEN
		_Halt[_k+NumberOfAxes]:=FALSE;
	END_IF
END_FOR

//
// CoordSystem := _SMC_GroupJog2.CoordSystem;
// ABC_as_ACS := _SMC_GroupJog2.ABC_as_ACS;
// Enabled := _SMC_GroupJog2.Enable;

//
_ErrorRtrig(CLK:=GroupHandler.Error
				//OR _SMC_GroupJog2.Error
				OR _MoveCommandProcessor.Error);			
IF _ErrorRtrig.Q THEN
	// TODO need to rework how error messages are handled (globally)
	// if the move command processor has an error, we dont know what it is.
	Error := TRUE;
END_IF

// do not put anything after this
_FirstScan := FALSE;]]></ST>
    </Implementation>
    <Method Name="_M_CheckOffsets" Id="{347358c3-2be2-4bfb-955f-c6b01631848c}">
      <Declaration><![CDATA[METHOD PRIVATE _M_CheckOffsets : BOOL
VAR
	_i: INT;
	_j: INT;
	_k: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN
	FOR _j:=0 TO GVL.MCS_POS_IDX-GVL.TCP_POS_IDX BY 1 DO
		_OffsetExist[_j] := FALSE;
	END_FOR
	FOR _i := GVL.TCP_POS_IDX TO GVL.MCS_POS_IDX BY 1 DO
		IF StoredPositions[_i].Position.X <> 0
			OR_ELSE StoredPositions[_i].Position.Y <> 0
			OR_ELSE StoredPositions[_i].Position.Z <> 0
			OR_ELSE StoredPositions[_i].Position.A <> 0
			OR_ELSE StoredPositions[_i].Position.B <> 0
			OR_ELSE StoredPositions[_i].Position.C <> 0 THEN
				_OffsetExist[_i - GVL.TCP_POS_IDX] := TRUE;
		END_IF
	END_FOR
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_HandleController" Id="{dcf131a0-32b4-4630-a728-b085ba029110}">
      <Declaration><![CDATA[METHOD PRIVATE _M_HandleController : BOOL
VAR_STAT
	OptionsTimer: TON := (PT := TIME#1s0ms);
	OptionsRtrig: R_TRIG;
	ShareTimer: TON := (PT := TIME#1s0ms);
	ShareRtrig: R_TRIG;
	OptionsShareRtrig: R_TRIG;
	JogEnabledRtrig: R_TRIG;
	JogEnabledFtrig: F_TRIG;
	SquareButtonRtrig: R_TRIG;
	TriangleButtonRtrig: R_TRIG;
	CircleButtonRtrig: R_TRIG;
	CrossButtonRtrig: R_TRIG;
	R2_Last: USINT;
	JoyStickLeftXLast: USINT;
	JoyStickLeftYLast: USINT;
	JoyStickRightXLast: USINT;
	JoyStickRightYLast: USINT;
	FactorMin: LREAL := 0.01;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// //
// OptionsTimer(IN:=Controller.P_State.Buttons.Options);
// OptionsRtrig(CLK:=Controller.P_State.Buttons.Options);
// //
// ShareTimer(IN:=Controller.P_State.Buttons.Share);
// ShareRtrig(CLK:=Controller.P_State.Buttons.Share);
// //
// OptionsShareRtrig(CLK:=OptionsTimer.Q AND_THEN ShareTimer.Q);
// JogEnabledRtrig(CLK:=Enable);
// JogEnabledFtrig(CLK:=Enable);
// 
// 
// IF Enable AND_THEN Controller.P_State.Connected THEN
// 	
// 	// toggle jog enable
// 	IF OptionsShareRtrig.Q THEN
// 		//_SMC_GroupJog2.Enable := NOT _SMC_GroupJog2.Enable;
// 	END_IF
// 	IF JogEnabledRtrig.Q OR JogEnabledFtrig.Q THEN
// 		IF Enable THEN
// 			_CoordSystem := DUT_CoordSystem.TCP;
// 			Controller.M_SetTriggerMode(E_ControllerTrigger.Right, E_ControllerTriggerMode.Rigid);
// 			Controller.M_SetTriggerForce(E_ControllerTrigger.Right, E_ControllerTriggerForceParameter.One, 0);
// 			Controller.M_SetPlayerID(E_ControllerPlayerID.PlayerALL);
// 			Controller.M_SetMicrophoneState(TRUE);
// 		ELSE
// 			Controller.M_SetTriggerMode(E_ControllerTrigger.Right, E_ControllerTriggerMode.Off);
// 			Controller.M_SetMicrophoneState(FALSE);
// 		END_IF
// 	END_IF
// 	
// 	// cycle through coord system
// 	IF OptionsRtrig.Q AND NOT Controller.P_State.Buttons.Share THEN
// 		CASE _.CoordSystem OF
// 			DUT_CoordSystem.ACS:
// 				_CoordSystem := DUT_CoordSystem.MCS;
// 				Controller.M_SetPlayerID(E_ControllerPlayerID.Player2);
// 			DUT_CoordSystem.MCS:
// 				_CoordSystem := DUT_CoordSystem.UCS1;
// 				Controller.M_SetPlayerID(E_ControllerPlayerID.Player3);
// 			DUT_CoordSystem.UCS1:
// 				_CoordSystem := DUT_CoordSystem.UCS2;
// 				Controller.M_SetPlayerID(E_ControllerPlayerID.Player4);
// 			DUT_CoordSystem.UCS2:
// 				_CoordSystem := DUT_CoordSystem.TCP;
// 				Controller.M_SetPlayerID(E_ControllerPlayerID.PlayerALL);
// 			DUT_CoordSystem.TCP:
// 				_CoordSystem := DUT_CoordSystem.ACS;
// 				Controller.M_SetPlayerID(E_ControllerPlayerID.Player1);
// // 			DUT_CoordSystem.WCS:
// // 				_CoordSystem := DUT_CoordSystem.ACS;
// // 				Controller.M_SetPlayerID(E_ControllerPlayerID.Player1);
// 		END_CASE
// 	END_IF
// 	
// 	// toggle the ABC as ACS setting
// 	IF ShareRtrig.Q AND NOT Controller.P_State.Buttons.Options THEN
// 		ABC_as_ACS := NOT ABC_as_ACS;
// 	END_IF
// 	
// 	// set the velocity factor while the left trigger button is pressed
// 	IF Controller.P_State.Dpad.Left AND_THEN Controller.P_State.Triggers.Right.Two <> R2_Last THEN
// 		R2_Last := Controller.P_State.Triggers.Right.Two;
// 		//_SMC_GroupJog2.VelFactor := MAX(FactorMin, Controller.P_State.Triggers.Right.Two * 1.0 / 255.0);
// 	END_IF
// 	// set the acceleration factor while the up dpad button is pressed
// 	IF Controller.P_State.Dpad.Up AND_THEN Controller.P_State.Triggers.Right.Two <> R2_Last THEN
// 		R2_Last := Controller.P_State.Triggers.Right.Two;
// 		//_SMC_GroupJog2.AccFactor := MAX(FactorMin, Controller.P_State.Triggers.Right.Two * 1.0 / 255.0);
// 	END_IF
// 	// set the jerk factor while the right dpad button is pressed
// 	IF Controller.P_State.Dpad.Right AND_THEN Controller.P_State.Triggers.Right.Two <> R2_Last THEN
// 		R2_Last := Controller.P_State.Triggers.Right.Two;
// 		//_SMC_GroupJog2.JerkFactor := MAX(FactorMin, Controller.P_State.Triggers.Right.Two * 1.0 / 255.0);
// 	END_IF
// 	// set the torque factor while the down dpad down is pressed
// 	IF Controller.P_State.Dpad.Down AND_THEN Controller.P_State.Triggers.Right.Two <> R2_Last THEN
// 		R2_Last := Controller.P_State.Triggers.Right.Two;
// 		//_SMC_GroupJog2.TorqueFactor := MAX(FactorMin, Controller.P_State.Triggers.Right.Two * 1.0 / 255.0);
// 	END_IF
// 	
// 	// first 4 poses can be called using buttons
// 	SquareButtonRtrig(CLK:=Controller.P_State.Buttons.Square);
// 	IF SquareButtonRtrig.Q THEN
// 		M_MoveToPose(E_Pose.One);
// 	END_IF
// 	TriangleButtonRtrig(CLK:=Controller.P_State.Buttons.Triangle);
// 	IF TriangleButtonRtrig.Q THEN
// 		M_MoveToPose(E_Pose.Two);
// 	END_IF
// 	CircleButtonRtrig(CLK:=Controller.P_State.Buttons.Circle);
// 	IF CircleButtonRtrig.Q THEN
// 		M_MoveToPose(E_Pose.Three);
// 	END_IF
// 	CrossButtonRtrig(CLK:=Controller.P_State.Buttons.Cross);
// 	IF CrossButtonRtrig.Q THEN
// 		M_MoveToPose(E_Pose.Four);
// 	END_IF
// 	
// 	//
// 	IF _SequenceMain = STEP_WAIT_JOG THEN
// 		
// 		//
// 		IF Controller.P_State.Joysticks.Left.X <> JoyStickLeftXLast
// 			OR Controller.P_State.Joysticks.Left.Y <> JoyStickLeftYLast THEN
// 				//
// 				JoyStickLeftXLast := Controller.P_State.Joysticks.Left.X;
// 				JoyStickLeftYLast := Controller.P_State.Joysticks.Left.Y;
// 				//	
// 				IF NOT Controller.P_State.Triggers.Left.One THEN
// 					// disable
// 					_JogForward[0] := FALSE;
// 					// disable
// 					_JogBackwards[0] := FALSE;
// 					// Controller.P_State.Joysticks.Left.X // X0-128 is -Y (Backward[1])
// 					_JogBackwards[1] := Controller.P_State.Joysticks.Left.X < _ControllerCenter - _ControllerDeadZone;
// 					// Controller.P_State.Joysticks.Left.X // X128-256 is +Y (Forward[1])
// 					_JogForward[1] := Controller.P_State.Joysticks.Left.X > _ControllerCenter + _ControllerDeadZone;
// 					// Controller.P_State.Joysticks.Left.Y // Y0-128 is +Z (Forward[2])
// 					_JogForward[2] := Controller.P_State.Joysticks.Left.Y < _ControllerCenter - _ControllerDeadZone;
// 					// Controller.P_State.Joysticks.Left.Y // Y128-256 is -Z (Backward[2])
// 					_JogBackwards[2] := Controller.P_State.Joysticks.Left.Y > _ControllerCenter + _ControllerDeadZone;
// 				ELSE
// 					// Controller.P_State.Joysticks.Left.Y // Y0-128 is +X (Forward[0])
// 					_JogForward[0] := Controller.P_State.Joysticks.Left.Y < _ControllerCenter - _ControllerDeadZone;
// 					// Controller.P_State.Joysticks.Left.Y // Y128-256 is -X (Backward[0])
// 					_JogBackwards[0] := Controller.P_State.Joysticks.Left.Y > _ControllerCenter + _ControllerDeadZone;
// 					// disable
// 					_JogBackwards[1] := FALSE;
// 					// disable
// 					_JogForward[1] := FALSE;
// 					// disable
// 					_JogForward[2] := FALSE;
// 					// disable])
// 					_JogBackwards[2] := FALSE;
// 				END_IF
// 		END_IF
// 
// 		//
// 		IF Controller.P_State.Joysticks.Right.X <> JoyStickRightXLast
// 			OR Controller.P_State.Joysticks.Right.Y <> JoyStickRightYLast THEN
// 				//
// 				JoyStickRightXLast := Controller.P_State.Joysticks.Right.X;
// 				JoyStickRightYLast := Controller.P_State.Joysticks.Right.Y;
// 				//				
// 				IF NOT Controller.P_State.Triggers.Right.One THEN
// 					// Controller.P_State.Joysticks.Right.X // X0-128 is +Roll (rot about x) (Forward[3])
// 					_JogBackwards[3] := Controller.P_State.Joysticks.Right.X > _ControllerCenter + _ControllerDeadZone;
// 					// Controller.P_State.Joysticks.Right.X // X128-256 is -Roll (rot about x) (Backward[3])
// 					_JogForward[3] := Controller.P_State.Joysticks.Right.X < _ControllerCenter - _ControllerDeadZone;
// 					// Controller.P_State.Joysticks.Right.Y // Y0-128 is +Pitch (rot about y) (Forward[4])
// 					_JogForward[4] := Controller.P_State.Joysticks.Right.Y < _ControllerCenter - _ControllerDeadZone;
// 					// Controller.P_State.Joysticks.Right.Y // Y128-256 is -Pitch (rot about y) (Backward[4])
// 					_JogBackwards[4] := Controller.P_State.Joysticks.Right.Y > _ControllerCenter + _ControllerDeadZone;
// 					// disable
// 					_JogBackwards[5] := FALSE;
// 					// disable
// 					_JogForward[5] := FALSE;
// 				ELSE
// 					// disable
// 					_JogBackwards[3] := FALSE;
// 					// disable
// 					_JogForward[3] := FALSE;
// 					// disable
// 					_JogForward[4] := FALSE;
// 					// disable
// 					_JogBackwards[4] := FALSE;
// 					// Controller.P_State.Joysticks.Right.X // X0-128 is -Yaw (rot about z) (Backward[5])
// 					_JogBackwards[5] := Controller.P_State.Joysticks.Right.X < _ControllerCenter - _ControllerDeadZone;
// 					// Controller.P_State.Joysticks.Right.X // X128-256 is +Yaw (rot about z) (Forward[5])
// 					_JogForward[5] := Controller.P_State.Joysticks.Right.X > _ControllerCenter + _ControllerDeadZone;
// 				END_IF
// 		END_IF
// 
// 	END_IF
// 	
// END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_HandlePose" Id="{043b4f3b-61e5-44ea-8800-b568d3612acd}">
      <Declaration><![CDATA[METHOD PRIVATE _M_HandlePose : BOOL
VAR
	_MoveCommand: ST_MoveCmd;
	_PoseSpeed: LREAL := 20.0;
	_i, _j, _k: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// FOR _i:=0 TO GVL.POSE_5_IDX - GVL.POSE_1_IDX BY 1 DO
// 	IF _MoveToPose[_i] THEN
// 		_MoveToPose[_i] := FALSE;
// 		//
// 		IF GVL.PowerOn 
// 			AND_THEN PersistentVars.Flags[GVL.HOME_COMPLETE].Value
// 			AND_THEN NOT _MoveCommandProcessor.Busy
// 			AND_THEN NOT _MoveCommandProcessor.Error THEN
// 				//
// 				_MoveCommand.MoveType 			:= DUT_Command_MoveType.DirectMove;
// 				_MoveCommand.PositionType 		:= DUT_Command_PositionType.AbsolutePosition;
// 				_MoveCommand.CoordinateType 	:= DUT_Command_CoordinateType.Literal;
// 				_MoveCommand.Speed 				:= _PoseSpeed;
// 				_MoveCommand.CoordSystem 		:= DUT_CoordSystem.ACS;
// 				_MoveCommand.CoordRef 			:= PersistentVars.StoredPositions[GVL.POSE_1_IDX + _i].Position;
// 				//
// 				_MoveCommandProcessor.Command := BuildMoveCmd(_MoveCommand);
// 				_MoveCommandProcessor.M_Start();
// 				//
// 				EXIT;
// 		END_IF;
// 	END_IF
// END_FOR
// 
// _MoveCommandProcessor(
// 	StoredPositions:= StoredPositions,
// 	VisionRegisters:= VisionRegisters,
// 	Flags:= Flags,
// 	AxisGroup:= AxisGroup, 
// 	GroupHandler:= GroupHandler,
// 	Velocity:= StoredPositions[GVL.SPEEDS_IDX].Position.X, 
// 	VelFactor:= StoredPositions[GVL.SPEEDS_IDX].Position.A,
// 	Acceleration:= StoredPositions[GVL.SPEEDS_IDX].Position.Y, 
// 	AccFactor:= StoredPositions[GVL.SPEEDS_IDX].Position.B,
// 	Jerk:= StoredPositions[GVL.SPEEDS_IDX].Position.Z,
// 	JerkFactor:= StoredPositions[GVL.SPEEDS_IDX].Position.C, 
// 	Position=> ,
// 	ItfUnitMode=> , 
// 	Error=> );]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ClearOffsets" Id="{5b18153f-c32f-4189-9485-f501f275c7f5}">
      <Declaration><![CDATA[METHOD M_ClearOffsets : BOOL
VAR
	_i, _j, _k: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR _j:=0 TO 3 BY 1 DO
	_OffsetExist[_j] := FALSE;
END_FOR
FOR _i := GVL.TCP_POS_IDX TO GVL.MCS_POS_IDX BY 1 DO
	StoredPositions[_i].Position.X := 0.0;
	StoredPositions[_i].Position.Y := 0.0;
	StoredPositions[_i].Position.Z := 0.0;
	StoredPositions[_i].Position.A := 0.0;
	StoredPositions[_i].Position.B := 0.0;
	StoredPositions[_i].Position.C := 0.0;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_MoveToPose" Id="{5971868c-619e-47a6-ac41-0e2ed68a066a}">
      <Declaration><![CDATA[METHOD M_MoveToPose : BOOL
VAR_INPUT
	Pose: E_Pose;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enabled 
	AND NOT _MoveCommandProcessor.Busy
	AND NOT _MoveCommandProcessor.Error THEN
		M_MoveToPose := TRUE;
		_MoveToPose[Pose] := TRUE;
ELSE
	M_MoveToPose := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>