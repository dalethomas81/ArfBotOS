<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_GroupHandler" Id="{f6416d9a-a888-4f6b-9b8f-cb306c7639e1}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_GroupHandler
VAR CONSTANT
	NumberOfAxes: UINT:=6;
END_VAR
VAR_IN_OUT
	AxisGroup: AXES_GROUP_REF;
	ACS: ARRAY[1..NumberOfAxes] OF AXIS_REF;
	MCS: ARRAY[1..NumberOfAxes] OF AXIS_REF;
END_VAR
VAR_INPUT
	Enable: BOOL;
	StoredPositions: REFERENCE TO ARRAY[GVL.POS_ARR_BEG..GVL.POS_ARR_END] OF DUT_StoredPosition;
END_VAR
VAR_OUTPUT
	Busy: BOOL;
	Error: BOOL;
	ErrorID: UDINT;
END_VAR
VAR
	
	_stKinToPlc      AT %I*     : NCTOPLC_NCICHANNEL_REF;
	_stPlcToKin     AT %Q*     : PLCTONC_NCICHANNEL_REF;
	
	//
	EnableFtrig: F_TRIG;
	
    _KinAxes: ST_KinAxes;
	
	//
	_SeqEnableGroup: INT;
	_SeqDisableGroup: INT;
	_SequenceSetKinematics: INT;
	_SequenceSetCoordTrans: INT;
	_SeqResetGroup: INT;
	
	//
	_FB_AddAllAxes: FB_AddAllAxes;
	_FB_PowerAll: FB_PowerAll;
	_GroupPower: BOOL;
	_MC_GroupEnable: MC_GroupEnable;
	_MC_GroupStop: MC_GroupStop;
	_MC_UngroupAllAxes: MC_UngroupAllAxes;
	_MC_GroupDisable: MC_GroupDisable;
	_FB_KinResetGroup: FB_KinResetGroup;
	_FB_KinCheckActualStatus: FB_KinCheckActualStatus;
    
    //
    _FB_KinConfigGroup: FB_KinConfigGroup;
	_McsCoordinateFrame: FB_CoordinateFrame;
	_Ucs1CoordinateFrame: FB_CoordinateFrame;
	_Ucs2CoordinateFrame: FB_CoordinateFrame;
	_TcpCoordinateFrame: FB_CoordinateFrame;
	_McsOffsetFrame: DUT_CoordFrame;
	_Ucs1OffsetFrame: DUT_CoordFrame;
	_Ucs2OffsetFrame: DUT_CoordFrame;
	_TcpOffsetFrame: DUT_CoordFrame;
	{attribute 'TcInitSymbol'}
	_OidEndNode_MCS: MC_COORD_REF;
	{attribute 'TcInitSymbol'}
	_OidEndNode_UCS1: MC_COORD_REF;
	{attribute 'TcInitSymbol'}
	_OidEndNode_UCS2: MC_COORD_REF;
	{attribute 'TcInitSymbol'}
	_OidEndNode_TCP: MC_COORD_REF;
	
	_MC_SetCoordinateTransform: MC_SetCoordinateTransform;
	_CoordinateSystem: DUT_CoordSystem;
	
	_EnableGroup: BOOL;
	_DisableGroup: BOOL;
	_GroupEnabled: BOOL;
	_ResetGroup: BOOL;
	_SetKinematics: BOOL;
	_SetCoordinates: BOOL;
	_KinematicsSet: BOOL;
	
	_MC_GroupReadStatus: MC_GroupReadStatus;
	_DUT_GroupStatus: DUT_GroupStatus;
	
	_i, _j, _k: UINT;
	
END_VAR

VAR CONSTANT
	STEP_DONE: 				INT := 1000;
	STEP_IDLE: 				INT := 0000;
	STEP_GROUP_POWER_ON: 	INT := 0022;
	STEP_WAIT_POWER_ON: 	INT := 0024;
	STEP_GROUP_ENABLE: 		INT := 0030;
	STEP_WAIT_ENABLE: 		INT := 0035;
	STEP_READ_POSITION: 	INT := 0040;
	STEP_WAIT_POSITION: 	INT := 0050;
	STEP_SET_KINEMATICS: 	INT := 0060;
	STEP_WAIT_KINEMATICS: 	INT := 0070;
	STEP_SET_COORD_TRANS: 	INT := 0071;
	STEP_WAIT_COORD_TRANS: 	INT := 0072;
	STEP_GROUP_DISABLE: 	INT := 0100;
	STEP_WAIT_DISABLE: 		INT := 0110;
	STEP_GROUP_POWER_OFF: 	INT := 0120;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//
Busy := _SeqEnableGroup <> 0
		OR _SeqDisableGroup <> 0
		OR _SequenceSetKinematics <> 0
		OR _SequenceSetCoordTrans <> 0
		OR _SeqResetGroup <> 0;
		
EnableFtrig(CLK:=Enable);
IF EnableFtrig.Q THEN
	M_DisableGroup();
END_IF

//
_M_EnableGroup();
_M_DisableGroup();
_M_SetKinematics();
_M_ResetGroup();

// https://infosys.beckhoff.com/content/1033/tf5240_kinematic_transformation/292852107.html?id=2424647827091372088
(* read the IDs from the cyclic axis interface so the axes can mapped later to the kinematic group *)
FOR _i:=1 TO NumberOfAxes BY 1 DO
	_KinAxes.nAxisIdsAcs[_i] := ACS[_i].NcToPlc.AxisId;
	_KinAxes.nAxisIdsMcs[_i] := MCS[_i].NcToPlc.AxisId;
END_FOR

//	
_FB_KinCheckActualStatus(
	bExecute:= , 
	stAxesListReference:= _KinAxes, 
	stKinRefIn:= _stKinToPlc, 
	eKinStatus=> , 
	bBusy=> , 
	bDone=> , 
	bError=> , 
	nErrorId=> );
	
// https://infosys.beckhoff.com/content/1033/tf5110-tf5113_tc3_kinematic_transformation/5737129739.html?id=6958083974342297833
// apparently we cannot use this for user specific transformations. dammit.
(*
_FB_KinCalcTrafo(
	bExecute:= , 
	bForward:= , 
	oidTrafo:= , // find object id in the General tab of the kinematic group
	stAxesPosIn:= , // if forward, these would be joint positions. if reverse, these would be cartesian
	stAxesPosOut:= , // if forward, these would be cartesian. if reverse, these would be joint positions
	uMetaInfoIn:= , 
	uMetaInfoOut:= , 
	bBusy=> , 
	bDone=> , 
	bError=> , 
	nErrorId=> );
*)

_MC_GroupReadStatus(
	AxesGroup:= AxisGroup, 
	Enable:= Enable, 
	Valid=> _DUT_GroupStatus.Valid, 
	Busy=> _DUT_GroupStatus.Busy, 
	GroupMoving=> _DUT_GroupStatus.GroupMoving, 
	GroupHoming=> _DUT_GroupStatus.GroupHoming, 
	GroupErrorStop=> _DUT_GroupStatus.GroupErrorStop, 
	GroupNotReady=> _DUT_GroupStatus.GroupNotReady, 
	GroupStandby=> _DUT_GroupStatus.GroupStandby, 
	GroupStopping=> _DUT_GroupStatus.GroupStopping, 
	GroupDisabled=> _DUT_GroupStatus.GroupDisabled, 
	AllAxesStanding=> _DUT_GroupStatus.AllAxesStanding, 
	InPosition=> _DUT_GroupStatus.InPosition, 
	Error=> _DUT_GroupStatus.Error, 
	ErrorId=> _DUT_GroupStatus.ErrorID);
IF _MC_GroupReadStatus.Error THEN
	//
ELSIF NOT _MC_GroupReadStatus.Valid THEN
	//	
END_IF
	
_FB_PowerAll(
	Enable:= _GroupPower, 
	acs:= ACS, 
	mcs:= MCS, 
	Status=> , 
	Error=> );
	
_FB_KinConfigGroup(
	bExecute:= , 
	bCartesianMode:= , 
	stAxesList:= _KinAxes, 
	stKinRefIn:= _stKinToPlc, 
	bBusy=> , 
	bDone=> , 
	bError=> , 
	nErrorId=> );
	
_FB_AddAllAxes(
	Execute:= , 
	stGroupRef:= AxisGroup, 
	mcs:= MCS, 
	Done=> , 
	Busy=> , 
	Error=> );

_MC_GroupEnable(
	AxesGroup:= AxisGroup, 
	Execute:= , 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );
	
_MC_GroupStop(
	AxesGroup:= AxisGroup, 
	Execute:= , 
	Deceleration:= , 
	Jerk:= MC_IGNORE, 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorId=> );
	
_MC_UngroupAllAxes(
	AxesGroup:= AxisGroup, 
	Execute:= , 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorId=> );
	
_MC_GroupDisable(
	AxesGroup:= AxisGroup, 
	Execute:= , 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );

_FB_KinResetGroup(
	bExecute:= , 
	nItpChannelId:= , 
	stKinRefIn:= _stKinToPlc, 
	stAxesList:= _KinAxes, 
	bBusy=> , 
	bDone=> , 
	bError=> , 
	nErrorId=> );
	
_McsCoordinateFrame(
	Execute:= , 
	oidTrafo:= _OidEndNode_MCS, 
	OffsetFrame:= _McsOffsetFrame, 
	Done=> , 
	Busy=> , 
	Error=> );
	
_Ucs1CoordinateFrame(
	Execute:= , 
	oidTrafo:= _OidEndNode_UCS1, 
	OffsetFrame:= _Ucs1OffsetFrame, 
	Done=> , 
	Busy=> , 
	Error=> );
	
_Ucs2CoordinateFrame(
	Execute:= , 
	oidTrafo:= _OidEndNode_UCS2, 
	OffsetFrame:= _Ucs2OffsetFrame, 
	Done=> , 
	Busy=> , 
	Error=> );
	
_TcpCoordinateFrame(
	Execute:= , 
	oidTrafo:= _OidEndNode_TCP, 
	OffsetFrame:= _TcpOffsetFrame, 
	Done=> , 
	Busy=> , 
	Error=> );
	
_MC_SetCoordinateTransform(
	AxesGroup:= AxisGroup, 
	Execute:= , 
	CoordTransform:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorId=> );]]></ST>
    </Implementation>
    <Method Name="_M_DisableGroup" Id="{17aa3a99-9fea-4672-a49a-0a0b6efeb4bc}">
      <Declaration><![CDATA[METHOD PRIVATE _M_DisableGroup : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE _SeqDisableGroup OF
	0: // IDLE
		IF _DisableGroup THEN
			_DisableGroup := FALSE;
			_MC_GroupDisable.Execute := FALSE;
			_MC_GroupEnable.Execute := FALSE;
			_SeqDisableGroup := _SeqDisableGroup + 1;
		END_IF
		
	1:
		_MC_GroupDisable.Execute := TRUE;
		_SeqDisableGroup := _SeqDisableGroup + 1;
		
	2:
		// TODO add timeout timer here
		IF _MC_GroupReadStatus.GroupDisabled THEN
			_SeqDisableGroup := _SeqDisableGroup + 1;;
		END_IF
		
	3:
		_MC_GroupDisable.Execute := FALSE;
		_GroupEnabled := FALSE;
		_KinematicsSet := FALSE;
		_GroupPower := FALSE;
		_SeqDisableGroup := 0;
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_EnableGroup" Id="{e90d231e-c7b2-4663-a0b5-e03a8bc3210e}">
      <Declaration><![CDATA[METHOD PRIVATE _M_EnableGroup : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE _SeqEnableGroup OF
	0: // IDLE
		IF _EnableGroup THEN
			_EnableGroup := FALSE;
			_GroupEnabled := FALSE;
			_MC_GroupEnable.Execute := FALSE;
			_SeqEnableGroup := _SeqEnableGroup + 1;
		END_IF
		
	1:
		_GroupPower := TRUE;
		_SeqEnableGroup := _SeqEnableGroup + 1;
		
	2:
		// TODO add timeout timer here
		IF _FB_PowerAll.Error THEN
			Error := TRUE;
			//ErrorID := _FB_PowerAll.ErrorID; // TODO get error ID
			_SeqEnableGroup := 0;
		ELSIF _FB_PowerAll.Status THEN
			_SeqEnableGroup := _SeqEnableGroup + 1;
		END_IF
		
	3:
		_MC_GroupEnable.Execute := TRUE;
		_SeqEnableGroup := _SeqEnableGroup + 1;
		
	4:
		// TODO add timeout timer here
		IF _MC_GroupEnable.Done THEN
			_GroupEnabled := TRUE;
			_SeqEnableGroup := 0;
		END_IF;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_ResetGroup" Id="{93550740-bce9-4d08-8c7b-68cd49bbfaa5}">
      <Declaration><![CDATA[METHOD PRIVATE _M_ResetGroup : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE _SeqResetGroup OF
	0: // IDLE
		IF _ResetGroup THEN
			_ResetGroup := FALSE;
			//IF Error THEN // could do this for auto reset. commenting out for now.
				_SeqResetGroup := _SeqResetGroup + 1;
			//END_IF
		END_IF
		
	1:
		Error := FALSE;
		ErrorID := 0;
		_FB_KinResetGroup.bExecute := TRUE;
		_SeqResetGroup := _SeqResetGroup + 1;
	
	2: 
		_FB_KinResetGroup.bExecute := FALSE;
		//
		_SeqEnableGroup := 0;
		_SeqDisableGroup := 0;
		_SequenceSetKinematics := 0;
		_SequenceSetCoordTrans := 0;
		_SeqResetGroup := 0;
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_SetKinematics" Id="{a1a7e940-4a9a-4003-92e9-8b3905bc4ae4}">
      <Declaration><![CDATA[METHOD PRIVATE _M_SetKinematics : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE _SequenceSetKinematics OF
	0: // IDLE
		IF _SetKinematics THEN
			_SetKinematics := FALSE;
			_KinematicsSet := FALSE;
			_FB_KinConfigGroup.bExecute := FALSE;
			_SequenceSetKinematics := _SequenceSetKinematics + 1;
		END_IF
		
	1: // set kinematics
		_FB_KinConfigGroup.bExecute := TRUE;
		_FB_KinConfigGroup.bCartesianMode := NOT (_CoordinateSystem = DUT_CoordSystem.ACS);
		_SequenceSetKinematics := _SequenceSetKinematics + 1;
		
	2: // wait for set kinematics
		// TODO add timeout timer here
		IF _FB_KinConfigGroup.bError THEN
			Error := TRUE;
			ErrorID := _FB_KinConfigGroup.nErrorId;
			_SequenceSetKinematics := 0;
		ELSIF _FB_KinConfigGroup.bDone THEN
			_FB_KinConfigGroup.bExecute := FALSE;
			_SequenceSetKinematics := _SequenceSetKinematics + 1;
		END_IF
		
	3: // wait for set coordinates
		// TODO add timeout timer here
		_SetCoordinates := TRUE;
		IF _SequenceSetCoordTrans <= 0 THEN
			_SequenceSetKinematics := _SequenceSetKinematics + 1;
		END_IF
		
	4:
		_MC_SetCoordinateTransform.Execute := TRUE;
		CASE _CoordinateSystem OF
			DUT_CoordSystem.ACS:
				_MC_SetCoordinateTransform.CoordTransform := _OidEndNode_MCS;
			DUT_CoordSystem.MCS:
				_MC_SetCoordinateTransform.CoordTransform := _OidEndNode_MCS;
			DUT_CoordSystem.UCS1:
				_MC_SetCoordinateTransform.CoordTransform := _OidEndNode_UCS1;
			DUT_CoordSystem.UCS2:
				_MC_SetCoordinateTransform.CoordTransform := _OidEndNode_UCS2;
			DUT_CoordSystem.TCP:
				_MC_SetCoordinateTransform.CoordTransform := _OidEndNode_TCP;
		END_CASE
	
	5: // wait for set coordinate transform
		// TODO add timeout timer here
		IF _MC_SetCoordinateTransform.Error THEN
			Error := TRUE;
			ErrorID := _MC_SetCoordinateTransform.ErrorID;
			_SequenceSetCoordTrans := 0;
			_SequenceSetKinematics := 0;
		ELSIF _SequenceSetCoordTrans <= 0 THEN
			_KinematicsSet := TRUE;
			_SequenceSetKinematics := 0;
		END_IF
		
END_CASE

CASE _SequenceSetCoordTrans OF
	0: //
		IF _SetCoordinates THEN
			_SetCoordinates := FALSE;
			_McsCoordinateFrame.Execute := FALSE;
			_Ucs1CoordinateFrame.Execute := FALSE;
			_Ucs2CoordinateFrame.Execute := FALSE;
			_TcpCoordinateFrame.Execute := FALSE;
			_SequenceSetCoordTrans := _SequenceSetCoordTrans + 1;
		END_IF
	
	1: //
		_McsOffsetFrame.Position := StoredPositions[GVL.MCS_POS_IDX].Position;
		_McsOffsetFrame.Interpretation := MC.CoordInterpretation_SO3.Rotation_Z3Y2X1_DIN9300; // TODO make configurable
		_McsOffsetFrame.Direction := MC.ReferenceDefDir.fromReference; // TODO make configurable
		_McsCoordinateFrame.Execute := TRUE;
		
		_Ucs1OffsetFrame.Position := StoredPositions[GVL.UC1_POS_IDX].Position;
		_Ucs1OffsetFrame.Interpretation := MC.CoordInterpretation_SO3.Rotation_Z3Y2X1_DIN9300; // TODO make configurable
		_Ucs1OffsetFrame.Direction := MC.ReferenceDefDir.fromReference; // TODO make configurable
		_Ucs1CoordinateFrame.Execute := TRUE;
		
		_Ucs2OffsetFrame.Position := StoredPositions[GVL.UC2_POS_IDX].Position;
		_Ucs2OffsetFrame.Interpretation := MC.CoordInterpretation_SO3.Rotation_Z3Y2X1_DIN9300; // TODO make configurable
		_Ucs2OffsetFrame.Direction := MC.ReferenceDefDir.fromReference; // TODO make configurable
		_Ucs2CoordinateFrame.Execute := TRUE;
		
		_TcpOffsetFrame.Position.X := MCS[1].NcToPlc.ActPos + StoredPositions[GVL.TCP_POS_IDX].Position.X;
		_TcpOffsetFrame.Position.Y := MCS[2].NcToPlc.ActPos + StoredPositions[GVL.TCP_POS_IDX].Position.Y;
		_TcpOffsetFrame.Position.Z := MCS[3].NcToPlc.ActPos + StoredPositions[GVL.TCP_POS_IDX].Position.Z;
		_TcpOffsetFrame.Position.A := MCS[4].NcToPlc.ActPos + StoredPositions[GVL.TCP_POS_IDX].Position.A;
		_TcpOffsetFrame.Position.B := MCS[5].NcToPlc.ActPos + StoredPositions[GVL.TCP_POS_IDX].Position.B;
		_TcpOffsetFrame.Position.C := MCS[6].NcToPlc.ActPos + StoredPositions[GVL.TCP_POS_IDX].Position.C;
		//_TcpOffsetFrame.Position := StoredPositions[GVL.TCP_POS_IDX].Position;
		_TcpOffsetFrame.Interpretation := MC.CoordInterpretation_SO3.Rotation_Z3Y2X1_DIN9300; // TODO make configurable
		_TcpOffsetFrame.Direction := MC.ReferenceDefDir.fromReference; // TODO make configurable
		_TcpCoordinateFrame.Execute := TRUE;
		_SequenceSetCoordTrans := _SequenceSetCoordTrans + 1;
		
	2: //
		// TODO add timeout timer here
		IF _McsCoordinateFrame.Error
			OR _Ucs1CoordinateFrame.Error
			OR _Ucs2CoordinateFrame.Error
			OR _TcpCoordinateFrame.Error THEN
				(*SUPER^.M_Error(Description:=CONCAT('Move Command Error: ',
											CONCAT(TO_STRING(_MC_SetCoordinateTransform.ErrorID),
											CONCAT(' ', SMC_ErrorString(_MC_SetCoordinateTransform.ErrorID,
														SMC_Language_Type.english)))));*)
				//SUPER^.M_Error(Description:=CONCAT('Move Command Error: ', TO_STRING(_MC_SetCoordinateTransform.ErrorID)));
				_SequenceSetCoordTrans := 10; // error step so we dont spam errors
			
		ELSIF _McsCoordinateFrame.Done 
				AND _Ucs1CoordinateFrame.Done 
				AND _Ucs2CoordinateFrame.Done 
				AND _TcpCoordinateFrame.Done THEN
					_McsCoordinateFrame.Execute := FALSE;
					_Ucs1CoordinateFrame.Execute := FALSE;
					_Ucs2CoordinateFrame.Execute := FALSE;
					_TcpCoordinateFrame.Execute := FALSE;
					_SequenceSetCoordTrans := 0;
		END_IF

END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_DisableGroup" Id="{a0a3246f-e788-42ad-9174-44a6b0b5864f}">
      <Declaration><![CDATA[METHOD M_DisableGroup : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//IF NOT Error THEN
	M_DisableGroup := TRUE;
	_DisableGroup := TRUE;
//ELSE
	//M_DisableGroup := FALSE;
//END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_EnableGroup" Id="{42afec78-5201-449e-b1b2-e5ed96e5c8b5}">
      <Declaration><![CDATA[METHOD M_EnableGroup : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable AND NOT Error THEN
	M_EnableGroup := TRUE;
	_EnableGroup := TRUE;
	_GroupEnabled := FALSE;
ELSE
	M_EnableGroup := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ResetGroup" Id="{f7b0fb23-a5d3-4128-86d4-545ea8eb93f8}">
      <Declaration><![CDATA[METHOD M_ResetGroup : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_ResetGroup := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_SetKinematics" Id="{c272ee22-b56a-4a21-938f-13e5df726fce}">
      <Declaration><![CDATA[METHOD M_SetKinematics : BOOL
VAR_INPUT
	CoordinateSystem: DUT_CoordSystem;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _GroupEnabled AND NOT Error THEN
	M_SetKinematics := TRUE;
	_CoordinateSystem := CoordinateSystem;
	_SetKinematics := TRUE;
	_KinematicsSet := FALSE;
ELSE
	M_SetKinematics := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="P_GroupEnabled" Id="{6c9aae5d-4785-4006-b6e7-a4e70fe8d11f}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'variable'}
PROPERTY P_GroupEnabled : BOOL
]]></Declaration>
      <Get Name="Get" Id="{dbc64c57-ffa9-4365-a52e-3fd1f7074869}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_GroupEnabled := _GroupEnabled;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_GroupStatus" Id="{7660ae4b-8965-424f-b336-9965f704e650}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'variable'}
PROPERTY P_GroupStatus : REFERENCE TO DUT_GroupStatus
]]></Declaration>
      <Get Name="Get" Id="{110897bc-c39e-4beb-86be-7c9059a2ea19}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_GroupStatus REF= _DUT_GroupStatus;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="P_KinematicsSet" Id="{ef1554af-fa41-4177-8dda-b53f3d39fa97}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'variable'}
PROPERTY P_KinematicsSet : BOOL
]]></Declaration>
      <Get Name="Get" Id="{ddb0a753-0308-444c-b527-ff5908f271b8}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_KinematicsSet := _KinematicsSet;]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>