<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="ParseCncCmd" Id="{4ea6ce2c-d973-415a-9620-8fd34fa576a4}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ParseCncCmd
VAR_INPUT
	Command: STRING(GVL.COMMAND_LEN);
END_VAR
VAR_OUTPUT
	stCommand: ST_CncCmd;
	Error: BOOL := FALSE;
	ErrorDescription: STRING;
END_VAR
VAR
	_CmdParams: ARRAY[0..GVL.COMMAND_LEN] OF STRING;
END_VAR
VAR CONSTANT
	_AddString: STRING(3) := 'ADD';
	_XYZString: STRING(3) := 'XYZ';
	_ZYXString: STRING(3) := 'ZYX';
	_ZYZString: STRING(3) := 'ZYZ';
	_LiteralString: STRING(3) := 'LIT';
	_VariableString: STRING(3) := 'VAR';
	_StoredPositionsString: STRING(3) := 'STO';
	_VisionRegistersString: STRING(3) := 'VIS';
	_FlagsString: STRING(3) := 'FLG';
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// /path/to/file/with/no/spaces/file.cnc ADD|XYX|ZYX|ZYZ startpos
// file1.cnc XYZ H +0250.00 +0000.00 +0500.00 +0000.00 +0045.00 +0180.00
// file2.cnc ADD A S 025
// file3.cnc ADD A V 015

Error := FALSE;
ErrorDescription:='';

// split command string into commands
_CmdParams:=F_SplitCmd(Command:=Command);

//
IF _CmdParams[0] <> '' THEN
	//
	stCommand.Filename:=_CmdParams[0];
	
	//
	IF _CmdParams[1] = _AddString THEN
		stCommand.OriConvention := SMC_ORI_CONVENTION.ADDAXES;
	ELSIF _CmdParams[1] = _XYZString THEN
		stCommand.OriConvention := SMC_ORI_CONVENTION.XYZ;
	ELSIF _CmdParams[1] = _ZYXString THEN
		stCommand.OriConvention := SMC_ORI_CONVENTION.ZYX;
	ELSIF _CmdParams[1] = _ZYZString THEN
		stCommand.OriConvention := SMC_ORI_CONVENTION.ZYZ;
	ELSE
		Error := TRUE;
		ErrorDescription:='No ori convention provided';
	END_IF
	
	//
	IF _CmdParams[2] = _LiteralString THEN
		// file1.cnc XYZ H +0250.00 +0000.00 +0500.00 +0000.00 +0045.00 +0180.00
		stCommand.StartPos.dX:=STRING_TO_LREAL(_CmdParams[3]);
		stCommand.StartPos.dY:=STRING_TO_LREAL(_CmdParams[4]);
		stCommand.StartPos.dZ:=STRING_TO_LREAL(_CmdParams[5]);
		stCommand.StartPos.dA:=STRING_TO_LREAL(_CmdParams[6]);
		stCommand.StartPos.dB:=STRING_TO_LREAL(_CmdParams[7]);
		stCommand.StartPos.dC:=STRING_TO_LREAL(_CmdParams[8]);
	ELSIF _CmdParams[2] = _VariableString THEN
		// file2.cnc ADD V S 025
		IF _CmdParams[3] = _StoredPositionsString THEN
			//_ArrayType:=DUT_Command_ArrayType.StoredPosition;
			stCommand.StartPos.dX:=PersistentVars.StoredPositions[STRING_TO_INT(_CmdParams[4])].Position.X; // TODO try to remove this reference to global vars
			stCommand.StartPos.dY:=PersistentVars.StoredPositions[STRING_TO_INT(_CmdParams[4])].Position.Y;
			stCommand.StartPos.dZ:=PersistentVars.StoredPositions[STRING_TO_INT(_CmdParams[4])].Position.Z;
			stCommand.StartPos.dA:=PersistentVars.StoredPositions[STRING_TO_INT(_CmdParams[4])].Position.A;
			stCommand.StartPos.dB:=PersistentVars.StoredPositions[STRING_TO_INT(_CmdParams[4])].Position.B;
			stCommand.StartPos.dC:=PersistentVars.StoredPositions[STRING_TO_INT(_CmdParams[4])].Position.C;
		ELSIF _CmdParams[3] = _VisionRegistersString THEN
			//_ArrayType:=DUT_Command_ArrayType.Vision;
			stCommand.StartPos.dX:=PersistentVars.VisionRegisters[STRING_TO_INT(_CmdParams[4])].Position.X;
			stCommand.StartPos.dY:=PersistentVars.VisionRegisters[STRING_TO_INT(_CmdParams[4])].Position.Y;
			stCommand.StartPos.dZ:=PersistentVars.VisionRegisters[STRING_TO_INT(_CmdParams[4])].Position.Z;
			stCommand.StartPos.dA:=PersistentVars.VisionRegisters[STRING_TO_INT(_CmdParams[4])].Position.A;
			stCommand.StartPos.dB:=PersistentVars.VisionRegisters[STRING_TO_INT(_CmdParams[4])].Position.B;
			stCommand.StartPos.dC:=PersistentVars.VisionRegisters[STRING_TO_INT(_CmdParams[4])].Position.C;
		ELSIF _CmdParams[3] = _FlagsString THEN
			//_ArrayType:=DUT_Command_ArrayType.Flag;
		ELSE
			Error := TRUE;
			ErrorDescription:='No array type provided';
		END_IF
	ELSE
		Error := TRUE;
		ErrorDescription:='No variable type provided';
	END_IF
	
ELSE
	Error := TRUE;
	ErrorDescription:='Command string format incorrect';
	
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>