<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MoveCmdProcessor" Id="{8f4275d6-46b8-4b53-89d9-00cb2bff4683}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK MoveCmdProcessor EXTENDS Module
VAR_INPUT
	Velocity: LREAL:=1000.0;
	VelFactor: LREAL:=1.0;
	Acceleration: LREAL:=1000.0;
	AccFactor: LREAL:=0.5;
	Jerk: LREAL:=1000.0;
	JerkFactor: LREAL:=0.5;
	Command: STRING(GVL.COMMAND_LEN):='';
END_VAR
VAR_IN_OUT
	AxisGroup: AXES_GROUP_REF;
	GroupHandler: FB_GroupHandler;
END_VAR
VAR_OUTPUT
	Position: DUT_COORD_REF;
END_VAR
VAR
	_SequenceSetCoordTrans: INT;
	_SequenceMoveCircularAbsolute: INT;
	_SequenceMoveCircularRelative: INT;
	_SequenceMoveDirectAbsolute: INT;
	_SequenceMoveDirectRelative: INT;
	_SequenceMoveLinearAbsolute: INT;
	_SequenceMoveLinearRelative: INT;
	_MC_GroupHalt: MC_GroupHalt;
	
	_MC_SetCoordinateTransformPreparation: MC_SetCoordinateTransformPreparation;
	_MC_MoveCircularAbsolutePreparation: MC_MoveCircularAbsolutePreparation;
	_MC_MoveLinearAbsolutePreparation: MC_MoveLinearAbsolutePreparation;
	
	_CoordRef: MC_COORD_REF;
	_buffer: ARRAY[1..4096] OF BYTE;
	_path: MC_PATH_DATA_REF(ADR(_buffer), SIZEOF(_buffer));
    _TargetPos: ARRAY[1.._NumberOfAxes] OF MC_LREAL;
    _TargetPos2: ARRAY[1.._NumberOfAxes] OF MC_LREAL;
    _TransitionParam: ARRAY[1..2] OF MC_LREAL;
    _MovePrepError: BOOL;
    _MC_MovePath: MC_MovePath;
	
	_UnitModeCurrentState: PACK_ML.State;
	_MoveCommandParser: ParseMoveCmd;
	_PosRef: DUT_COORD_REF;
	_PosRef2: DUT_COORD_REF;
	
	_MC_MoveRelative: ARRAY[1.._NumberOfAxes] OF MC_MoveRelative;
	_MoveDistance: ARRAY[1.._NumberOfAxes] OF LREAL:=[0,0,0,0,0,0];
	_MC_MoveAbsolute: ARRAY[1.._NumberOfAxes] OF MC_MoveAbsolute;
	_MovePosition: ARRAY[1.._NumberOfAxes] OF LREAL:=[0,0,0,0,0,0];
	
	_i, _j, _k: UINT;
END_VAR
VAR CONSTANT
	_NumberOfAxes:				UINT := GVL.NumberOfAxes;
	_STEP_DONE: 				INT := 1000;
	_STEP_IDLE: 				INT := 0000;
	_STEP_COMMAND: 				INT := 0020;
	_STEP_GROUP_POWER_ON: 		INT := 0022;
	_STEP_WAIT_POWER_ON: 		INT := 0024;
	_STEP_GROUP_ENABLE: 		INT := 0030;
	_STEP_WAIT_ENABLE: 			INT := 0035;
	_STEP_READ_POSITION: 		INT := 0040;
	_STEP_WAIT_POSITION: 		INT := 0050;
	_STEP_SET_KINEMATICS: 		INT := 0060;
	_STEP_WAIT_KINEMATICS: 		INT := 0070;
	_STEP_SET_COORD_TRANS:		INT := 0071;
	_STEP_WAIT_COORD_TRANS:		INT := 0072;
	_STEP_MOVE_TYPE:			INT := 0080;
	_STEP_WAIT_MOVE: 			INT := 0090;
	_STEP_GROUP_DISABLE: 		INT := 0100;
	_STEP_WAIT_DISABLE: 		INT := 0110;
	_STEP_GROUP_POWER_OFF: 		INT := 0120;
	_STEP_ERR: 					INT := 9999;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[SUPER^();

// PackML state machine implementation
_UnitModeCurrentState := SUPER^._UnitMode.CurrentState;

//
CASE SUPER^._SeqMain OF
	
	_STEP_DONE:
		SUPER^._SeqMain := _STEP_IDLE;
		
	_STEP_IDLE:
		// wait here until commanded to start
		
	_STEP_COMMAND: // parse command
		_MoveCommandParser(Command:=Command);
		SUPER^._SeqMain := _STEP_GROUP_ENABLE;
		
	_STEP_GROUP_ENABLE:
		IF GroupHandler.M_EnableGroup(_MoveCommandParser.stCommand.CoordSystem) THEN
			SUPER^._SeqMain := _STEP_WAIT_ENABLE;
		ELSE
			(*SUPER^.M_Error(Description:=CONCAT('Group Handler Error: ',
										CONCAT(TO_STRING(GroupHandler.ErrorID),
										CONCAT(' ', SMC_ErrorString(GroupHandler.ErrorID,
													SMC_Language_Type.english)))));*)
			SUPER^.M_Error(Description:=CONCAT('Group Handler Error: ', TO_STRING(GroupHandler.ErrorID)));
			SUPER^._SeqMain := _STEP_ERR; // error step so we dont spam errors
		END_IF
		
	_STEP_WAIT_ENABLE:
		// TODO add timeout timer here?
		IF GroupHandler.P_GroupEnabled THEN
			SUPER^._SeqMain := _STEP_MOVE_TYPE;
		END_IF;
		
	_STEP_MOVE_TYPE: // parse move type
		_PosRef := _MoveCommandParser.stCommand.CoordRef;
		_PosRef2 := _MoveCommandParser.stCommand.CoordRef2; // the second position here is used for circular moves
		IF _MoveCommandParser.stCommand.MoveType = DUT_Command_MoveType.CircularMove THEN
			IF _MoveCommandParser.stCommand.PositionType = DUT_Command_PositionType.AbsolutePosition THEN
				_SequenceMoveCircularAbsolute := 1;
			ELSIF _MoveCommandParser.stCommand.PositionType = DUT_Command_PositionType.RelativePosition THEN
				_SequenceMoveCircularRelative := 1;
			END_IF
			
		ELSIF _MoveCommandParser.stCommand.MoveType = DUT_Command_MoveType.DirectMove THEN
			IF _MoveCommandParser.stCommand.PositionType = DUT_Command_PositionType.AbsolutePosition THEN
				_SequenceMoveDirectAbsolute := 1;
			ELSIF _MoveCommandParser.stCommand.PositionType = DUT_Command_PositionType.RelativePosition THEN
				_SequenceMoveDirectRelative := 1;
			END_IF
			
		ELSIF _MoveCommandParser.stCommand.MoveType = DUT_Command_MoveType.LinearMove THEN
			IF _MoveCommandParser.stCommand.PositionType = DUT_Command_PositionType.AbsolutePosition THEN
				_SequenceMoveLinearAbsolute := 1;
			ELSIF _MoveCommandParser.stCommand.PositionType = DUT_Command_PositionType.RelativePosition THEN
				_SequenceMoveLinearRelative := 1;
			END_IF
		END_IF
		
		SUPER^._SeqMain := _STEP_WAIT_MOVE;
		
	_STEP_WAIT_MOVE: // wait for move complete
		IF _SequenceMoveCircularAbsolute = 0
			AND _SequenceMoveCircularRelative = 0 
			AND _SequenceMoveDirectAbsolute = 0 
			AND _SequenceMoveDirectRelative = 0
			AND _SequenceMoveLinearAbsolute = 0
			AND _SequenceMoveLinearRelative = 0 THEN
				SUPER^._SeqMain := _STEP_GROUP_DISABLE;
				//SUPER^._SeqMain := _STEP_DONE;
		END_IF
	
	// TODO do we need to disable the group at this point? lets leave this here for now but skip it.
	_STEP_GROUP_DISABLE: 
		IF GroupHandler.M_DisableGroup() THEN
			SUPER^._SeqMain := _STEP_WAIT_DISABLE;
		ELSE
			(*SUPER^.M_Error(Description:=CONCAT('Group Handler Error: ',
										CONCAT(TO_STRING(GroupHandler.ErrorID),
										CONCAT(' ', SMC_ErrorString(GroupHandler.ErrorID,
													SMC_Language_Type.english)))));*)
			SUPER^.M_Error(Description:=CONCAT('Group Handler Error: ', TO_STRING(GroupHandler.ErrorID)));
			SUPER^._SeqMain := _STEP_ERR; // error step so we dont spam errors
		END_IF
		
	_STEP_WAIT_DISABLE:
		IF NOT GroupHandler.P_GroupEnabled THEN
			SUPER^._SeqMain := _STEP_DONE;
		END_IF
	
END_CASE

CASE _SequenceMoveCircularAbsolute OF
	0: //
	
	1: //
		_MC_MovePath.Execute := FALSE;
		A_AddLinAbsCircPath();
		_SequenceMoveCircularAbsolute := _SequenceMoveCircularAbsolute + 1;
		
	2: // 
		// TODO add timeout timer here
		IF _MovePrepError THEN
			(*SUPER^.M_Error(Description:=CONCAT('Move Command Error: ',
										CONCAT(TO_STRING(_MC_MoveLinearAbsolute.ErrorID),
										CONCAT(' ', SMC_ErrorString(_MC_MoveLinearAbsolute.ErrorID,
													SMC_Language_Type.english)))));*)
			//SUPER^.M_Error(Description:=CONCAT('Move Command Error: ', TO_STRING(_MC_MoveLinearAbsolute.ErrorID)));
			_SequenceMoveCircularAbsolute := 99; // error step so we dont spam errors
			
		ELSE
			_SequenceMoveCircularAbsolute := _SequenceMoveCircularAbsolute + 1;
		END_IF
		
	3: //
		_MC_MovePath.Execute := TRUE;
		_SequenceMoveCircularAbsolute := _SequenceMoveCircularAbsolute + 1;
		
	4: //
		// TODO add timeout timer here
		IF _MC_MovePath.Error THEN
			(*SUPER^.M_Error(Description:=CONCAT('Move Command Error: ',
										CONCAT(TO_STRING(_MC_MoveLinearAbsolute.ErrorID),
										CONCAT(' ', SMC_ErrorString(_MC_MoveLinearAbsolute.ErrorID,
													SMC_Language_Type.english)))));*)
			SUPER^.M_Error(Description:=CONCAT('Move Command Error: ', TO_STRING(_MC_MovePath.ErrorID)));
			_SequenceMoveCircularAbsolute := 99; // error step so we dont spam errors
			
		ELSIF _MC_MovePath.Done THEN
			_SequenceMoveCircularAbsolute := 0;
			
		END_IF
		
END_CASE

// CASE _SequenceMoveCircularRelative OF
// 	0: //
// 	
// 	1: //
// 		_MC_MoveCircularRelative.Execute := TRUE;
// 		_SequenceMoveCircularRelative := 2;
// 		
// 	2: //
// 		IF _MC_MoveCircularRelative.Error THEN
// 			(*SUPER^.M_Error(Description:=CONCAT('Move Command Error: ',
// 										CONCAT(TO_STRING(_MC_MoveCircularRelative.ErrorID),
// 										CONCAT(' ', SMC_ErrorString(_MC_MoveCircularRelative.ErrorID,
// 													SMC_Language_Type.english)))));*)
// 			SUPER^.M_Error(Description:=CONCAT('Move Command Error: ', TO_STRING(_MC_MoveCircularRelative.ErrorID)));
// 			_SequenceMoveCircularRelative := 3; // error step so we dont spam errors
// 		ELSIF  _MC_MoveCircularRelative.Done THEN
// 			_MC_MoveCircularRelative.Execute := FALSE;
// 			_SequenceMoveCircularRelative := 0;
// 		END_IF
// 		
// END_CASE

// CASE _SequenceMoveDirectAbsolute OF
// 	0: //
// 	
// 	1: //
// 		_MC_MoveDirectAbsolute.Execute := TRUE;
// 		_SequenceMoveDirectAbsolute := 2;
// 		
// 	2: //
// 		IF _MC_MoveDirectAbsolute.Error THEN
// 			(*SUPER^.M_Error(Description:=CONCAT('Move Command Error: ',
// 										CONCAT(TO_STRING(_MC_MoveDirectAbsolute.ErrorID),
// 										CONCAT(' ', SMC_ErrorString(_MC_MoveDirectAbsolute.ErrorID,
// 													SMC_Language_Type.english)))));*)
// 			SUPER^.M_Error(Description:=CONCAT('Move Command Error: ', TO_STRING(_MC_MoveDirectAbsolute.ErrorID)));
// 			_SequenceMoveDirectAbsolute := 3; // error step so we dont spam errors
// 			
// 		ELSIF _MC_MoveDirectAbsolute.Done THEN
// 			_MC_MoveDirectAbsolute.Execute := FALSE;
// 			_SequenceMoveDirectAbsolute := 0;
// 		END_IF
// 		
// END_CASE

// CASE _SequenceMoveDirectRelative OF
// 	0: //
// 	
// 	1: //
// 		_MC_MoveDirectRelative.Execute := TRUE;
// 		_SequenceMoveDirectRelative := 2;
// 		
// 	2: //
// 		IF _MC_MoveDirectRelative.Error THEN
// 			(*SUPER^.M_Error(Description:=CONCAT('Move Command Error: ',
// 										CONCAT(TO_STRING(_MC_MoveDirectRelative.ErrorID),
// 										CONCAT(' ', SMC_ErrorString(_MC_MoveDirectRelative.ErrorID,
// 													SMC_Language_Type.english)))));*)
// 			SUPER^.M_Error(Description:=CONCAT('Move Command Error: ', TO_STRING(_MC_MoveDirectRelative.ErrorID)));
// 			_SequenceMoveDirectRelative := 3; // error step so we dont spam errors
// 			
// 		ELSIF _MC_MoveDirectRelative.Done THEN
// 			_MC_MoveDirectRelative.Execute := FALSE;
// 			_SequenceMoveDirectRelative := 0;
// 		END_IF
// 		
// END_CASE

CASE _SequenceMoveLinearAbsolute OF
	0: //
	
	1: //
		_MC_MovePath.Execute := FALSE;
		A_AddLinAbsPath();
		_SequenceMoveLinearAbsolute := _SequenceMoveLinearAbsolute + 1;
		
	2: // 
		// TODO add timeout timer here
		IF _MovePrepError THEN
			(*SUPER^.M_Error(Description:=CONCAT('Move Command Error: ',
										CONCAT(TO_STRING(_MC_MoveLinearAbsolute.ErrorID),
										CONCAT(' ', SMC_ErrorString(_MC_MoveLinearAbsolute.ErrorID,
													SMC_Language_Type.english)))));*)
			//SUPER^.M_Error(Description:=CONCAT('Move Command Error: ', TO_STRING(_MC_MoveLinearAbsolute.ErrorID)));
			_SequenceMoveLinearAbsolute := 99; // error step so we dont spam errors
			
		ELSE
			_SequenceMoveLinearAbsolute := _SequenceMoveLinearAbsolute + 1;
		END_IF
		
	3: //
		_MC_MovePath.Execute := TRUE;
		_SequenceMoveLinearAbsolute := _SequenceMoveLinearAbsolute + 1;
		
	4: //
		// TODO add timeout timer here
		IF _MC_MovePath.Error THEN
			(*SUPER^.M_Error(Description:=CONCAT('Move Command Error: ',
										CONCAT(TO_STRING(_MC_MoveLinearAbsolute.ErrorID),
										CONCAT(' ', SMC_ErrorString(_MC_MoveLinearAbsolute.ErrorID,
													SMC_Language_Type.english)))));*)
			SUPER^.M_Error(Description:=CONCAT('Move Command Error: ', TO_STRING(_MC_MovePath.ErrorID)));
			_SequenceMoveLinearAbsolute := 99; // error step so we dont spam errors
			
		ELSIF _MC_MovePath.Done THEN
			_SequenceMoveLinearAbsolute := 0;
			
		END_IF
		
END_CASE

// CASE _SequenceMoveLinearRelative OF
// 	0: //
// 	
// 	1: //
// 		_MC_MoveLinearRelative.Execute := TRUE;
// 		_SequenceMoveLinearRelative := 2;
// 		
// 	2: //
// 		IF _MC_MoveLinearRelative.Error THEN
// 		    (*SUPER^.M_Error(Description:=CONCAT('Move Command Error: ',
// 										CONCAT(TO_STRING(_MC_MoveLinearRelative.ErrorID),
// 										CONCAT(' ', SMC_ErrorString(_MC_MoveLinearRelative.ErrorID,
// 													SMC_Language_Type.english)))));*)
// 			SUPER^.M_Error(Description:=CONCAT('Move Command Error: ', TO_STRING(_MC_MoveLinearRelative.ErrorID)));
// 			_SequenceMoveLinearRelative := 3; // error step so we dont spam errors
// 			
// 		ELSIF _MC_MoveLinearRelative.Done THEN
// 			_MC_MoveLinearRelative.Execute := FALSE;
// 			_SequenceMoveLinearRelative := 0;
// 		END_IF
// 		
// END_CASE

_MC_GroupHalt(
	AxesGroup:= AxisGroup, 
	Execute:= , 
	Deceleration:= Acceleration, 
	Jerk:= JerkFactor, 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorId=> );
	
_MC_MovePath(
	AxesGroup:= AxisGroup, 
	PathData:= _Path, 
	Execute:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorId=> );

// https://content.helpme-codesys.com/de/libs/SM3_Robotics/Current/SM3_Robotics/POUs/Movement/MC_MoveCircularAbsolute.html
// https://content.helpme-codesys.com/de/libs/SM3_Robotics/Current/SM3_Robotics/Basic-types/SMC_CIRC_MODE.html#smc-circ-mode
// _MC_MoveCircularAbsolute(
// 	AxisGroup:= AxisGroup, 
// 	Execute:= , 
// 	CircMode:= _MoveCommandParser.stCommand.CircleMode, 
// 	AuxPoint:= _PosRef, 
// 	EndPoint:= _PosRef2, 
// 	PathChoice:= _MoveCommandParser.stCommand.PathChoice, 
// 	Velocity:= Velocity, 
// 	Acceleration:= Acceleration, 
// 	Deceleration:= Acceleration, 
// 	Jerk:= Jerk, 
// 	CoordSystem:= _MoveCommandParser.stCommand.CoordSystem, 
// 	BufferMode:= , 
// 	TransitionMode:= , 
// 	TransitionParameter:= , 
// 	OrientationMode:= , 
// 	VelFactor:= SEL(_MoveCommandParser.stCommand.Speed > 100, _MoveCommandParser.stCommand.Speed / 100.0, 1), // cannot be greater than 1
// 	AccFactor:= SEL(AccFactor > 1, AccFactor, 1), 
// 	JerkFactor:= SEL(JerkFactor > 1, JerkFactor, 1), 
// 	TorqueFactor:= 1, 
// 	Done=> , 
// 	Busy=> , 
// 	Active=> , 
// 	CommandAborted=> , 
// 	CommandAccepted=> , 
// 	Error=> , 
// 	ErrorID=> , 
// 	MovementId=> );

// https://content.helpme-codesys.com/en/libs/SM3_Robotics/Current/SM3_Robotics/POUs/Movement/MC_MoveCircularRelative.html
// https://content.helpme-codesys.com/de/libs/SM3_Robotics/Current/SM3_Robotics/Basic-types/SMC_CIRC_MODE.html#smc-circ-mode
// _MC_MoveCircularRelative(
// 	AxisGroup:= AxisGroup, 
// 	Execute:= , 
// 	CircMode:= _MoveCommandParser.stCommand.CircleMode, 
// 	AuxPoint:= _PosRef, 
// 	EndPoint:= _PosRef2, 
// 	PathChoice:= _MoveCommandParser.stCommand.PathChoice, 
// 	Velocity:= Velocity, 
// 	Acceleration:= Acceleration, 
// 	Deceleration:= Acceleration, 
// 	Jerk:= Jerk, 
// 	CoordSystem:= _MoveCommandParser.stCommand.CoordSystem, 
// 	BufferMode:= , 
// 	TransitionMode:= , 
// 	TransitionParameter:= , 
// 	OrientationMode:= , 
// 	VelFactor:= SEL(_MoveCommandParser.stCommand.Speed > 100, _MoveCommandParser.stCommand.Speed / 100.0, 1), // cannot be greater than 1
// 	AccFactor:= SEL(AccFactor > 1, AccFactor, 1), 
// 	JerkFactor:= SEL(JerkFactor > 1, JerkFactor, 1), 
// 	TorqueFactor:= 1, 
// 	Done=> , 
// 	Busy=> , 
// 	Active=> , 
// 	CommandAborted=> , 
// 	CommandAccepted=> , 
// 	Error=> , 
// 	ErrorID=> , 
// 	MovementId=> );


// // move relative
// FOR _k:= 1 TO _NumberOfAxes DO
// 	_MC_MoveRelative[_k](
// 		Axis:= SEL(_MoveCommandParser.stCommand.CoordSystem = DUT_CoordSystem.ACS, MCS[_k], ACS[_k]), 
// 		Execute:= , 
// 		Distance:= _MoveDistance[_k], 
// 		Velocity:= _MoveCommandParser.stCommand.Speed, 
// 		Acceleration:= MC_DEFAULT, 
// 		Deceleration:= MC_DEFAULT, 
// 		Jerk:= MC_DEFAULT, 
// 		BufferMode:= , 
// 		Options:= , 
// 		Done=> , 
// 		Busy=> , 
// 		Active=> , 
// 		CommandAborted=> , 
// 		Error=> , 
// 		ErrorID=> );
// END_FOR

// FOR _k:= 1 TO _NumberOfAxes DO
// 	_MC_MoveAbsolute[_k](
// 		Axis:= SEL(_MoveCommandParser.stCommand.CoordSystem = DUT_CoordSystem.ACS, MCS[_k], ACS[_k]), 
// 		Execute:= , 
// 		Position:= _MovePosition[_k], 
// 		Velocity:= _MoveCommandParser.stCommand.Speed, 
// 		Acceleration:= MC_DEFAULT, 
// 		Deceleration:= MC_DEFAULT, 
// 		Jerk:= MC_DEFAULT, 
// 		BufferMode:= , 
// 		Options:= , 
// 		Done=> , 
// 		Busy=> , 
// 		Active=> , 
// 		CommandAborted=> , 
// 		Error=> , 
// 		ErrorID=> );
// END_FOR

// _MC_MoveDirectAbsolute(
// 	AxisGroup:=AxisGroup,
// 	Execute:= ,
// 	Position:= _PosRef,
// 	MovementType:= ,
// 	CoordSystem:= _MoveCommandParser.stCommand.CoordSystem,
// 	BufferMode:= ,
// 	TransitionMode:= ,
// 	TransitionParameter:= ,
// 	VelFactor:= SEL(_MoveCommandParser.stCommand.Speed > 100, _MoveCommandParser.stCommand.Speed / 100.0, 1), // cannot be greater than 1
// 	AccFactor:= SEL(AccFactor > 1, AccFactor, 1), 
// 	JerkFactor:= SEL(JerkFactor > 1, JerkFactor, 1), 
// 	TorqueFactor:= 1,
// 	Done=> ,
// 	Busy=> ,
// 	Active=> ,
// 	CommandAborted=> ,
// 	CommandAccepted=> ,
// 	Error=> ,
// 	ErrorID=> ,
// 	MovementId=> );

// _MC_MoveDirectRelative(
// 	AxisGroup:= AxisGroup, 
// 	Execute:= , 
// 	Distance:= _PosRef, 
// 	MovementType:= , 
// 	CoordSystem:= _MoveCommandParser.stCommand.CoordSystem, 
// 	BufferMode:= , 
// 	TransitionMode:= , 
// 	TransitionParameter:= , 
// 	VelFactor:= SEL(_MoveCommandParser.stCommand.Speed > 100, _MoveCommandParser.stCommand.Speed / 100.0, 1), // cannot be greater than 1
// 	AccFactor:= SEL(AccFactor > 1, AccFactor, 1), 
// 	JerkFactor:= SEL(JerkFactor > 1, JerkFactor, 1), 
// 	TorqueFactor:= 1, 
// 	Done=> , 
// 	Busy=> , 
// 	Active=> , 
// 	CommandAborted=> , 
// 	CommandAccepted=> , 
// 	Error=> , 
// 	ErrorID=> , 
// 	MovementId=> );
	
// _MC_MoveLinearAbsolute(
// 	AxisGroup:= AxisGroup, 
// 	Execute:= , 
// 	Position:= _PosRef,
// 	Velocity:= 1000, 
// 	Acceleration:= Acceleration, 
// 	Deceleration:= Acceleration, 
// 	Jerk:= Jerk, 
// 	CoordSystem:= _MoveCommandParser.stCommand.CoordSystem, 
// 	BufferMode:= , 
// 	TransitionMode:= , 
// 	TransitionParameter:= , 
// 	OrientationMode:= , 
// 	VelFactor:= SEL(_MoveCommandParser.stCommand.Speed > 100, _MoveCommandParser.stCommand.Speed / 100.0, 1), // cannot be greater than 1
// 	AccFactor:= SEL(AccFactor > 1, AccFactor, 1), 
// 	JerkFactor:= SEL(JerkFactor > 1, JerkFactor, 1), 
// 	TorqueFactor:= 1, 
// 	Done=> , 
// 	Busy=> , 
// 	Active=> , 
// 	CommandAborted=> , 
// 	CommandAccepted=> , 
// 	Error=> , 
// 	ErrorID=> , 
// 	MovementId=> );
	
// _MC_MoveLinearRelative(
// 	AxisGroup:= AxisGroup, 
// 	Execute:= , 
// 	Distance:= _PosRef, 
// 	Velocity:= 1000, 
// 	Acceleration:= Acceleration, 
// 	Deceleration:= Acceleration, 
// 	Jerk:= Jerk, 
// 	CoordSystem:= _MoveCommandParser.stCommand.CoordSystem, 
// 	BufferMode:= , 
// 	TransitionMode:= , 
// 	TransitionParameter:= , 
// 	OrientationMode:= , 
// 	VelFactor:= SEL(_MoveCommandParser.stCommand.Speed > 100, _MoveCommandParser.stCommand.Speed / 100.0, 1), // cannot be greater than 1
// 	AccFactor:= SEL(AccFactor > 1, AccFactor, 1), 
// 	JerkFactor:= SEL(JerkFactor > 1, JerkFactor, 1), 
// 	TorqueFactor:= 1, 
// 	Done=> , 
// 	Busy=> , 
// 	Active=> , 
// 	CommandAborted=> , 
// 	CommandAccepted=> , 
// 	Error=> , 
// 	ErrorID=> , 
// 	MovementId=> );]]></ST>
    </Implementation>
    <Folder Name="PathPlanning" Id="{c0534be7-6a45-4d50-bad5-cf9e02741379}" />
    <Action Name="A_AddLinAbsCircPath" Id="{33a9f7f5-5a80-4d5d-981d-e39aaeb5c2ae}" FolderPath="PathPlanning\">
      <Implementation>
        <ST><![CDATA[_MovePrepError := FALSE;
_path.ClearPath();  //Clear nodes that were in path

//
CASE _MoveCommandParser.stCommand.CoordSystem OF
	DUT_CoordSystem.ACS:
		_CoordRef := GVL.McsCoordRef; // TODO: we shouldnt be here. maybe fault?
	DUT_CoordSystem.MCS:
		_CoordRef := GVL.McsCoordRef;
	DUT_CoordSystem.UCS1:
		_CoordRef := GVL.Ucs1CoordRef;
	DUT_CoordSystem.UCS2:
		_CoordRef := GVL.Ucs2CoordRef;
	DUT_CoordSystem.TCP:
		_CoordRef := GVL.TcpCoordRef;
END_CASE
_MC_SetCoordinateTransformPreparation(PathData:=_path, CoordTransform:=_CoordRef);
_MovePrepError := _MovePrepError OR _MC_SetCoordinateTransformPreparation.Error;

_TargetPos[1]				:= _PosRef.X;
_TargetPos[2]				:= _PosRef.Y;
_TargetPos[3]				:= _PosRef.Z;
_TargetPos[4]				:= GroupHandler.P_GroupStatus.CurrentPosition.A + _PosRef.A;
_TargetPos[5]				:= GroupHandler.P_GroupStatus.CurrentPosition.B + _PosRef.B;
_TargetPos[6]				:= GroupHandler.P_GroupStatus.CurrentPosition.C + _PosRef.C;
_TargetPos2[1]				:= _PosRef2.X;
_TargetPos2[2]				:= _PosRef2.Y;
_TargetPos2[3]				:= _PosRef2.Z;
_TargetPos2[4]				:= GroupHandler.P_GroupStatus.CurrentPosition.A + _PosRef.A;
_TargetPos2[5]				:= GroupHandler.P_GroupStatus.CurrentPosition.B + _PosRef.B;
_TargetPos2[6]				:= GroupHandler.P_GroupStatus.CurrentPosition.C + _PosRef.C;
_TransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
_TransitionParam[2]			:= 0; //blending distance on this segment, no influence here

_MC_MoveCircularAbsolutePreparation(
	PathData:= _path, 
	CircMode:= _MoveCommandParser.stCommand.CircleMode, 
	AuxPoint:= ADR(_TargetPos), 
	AuxPointCount:= 3, 
	EndPoint:= ADR(_TargetPos2), 
	EndPointCount:= _NumberOfAxes, 
	PathChoice:= _MoveCommandParser.stCommand.PathChoice, 
	Velocity:= _MoveCommandParser.stCommand.Speed, 
	Acceleration:= MC_DEFAULT, 
	Deceleration:= MC_DEFAULT, 
	Jerk:= MC_DEFAULT, 
	BufferMode:= mcBlendingPrevious, 
	TransitionMode:= mcTransModeCornerDistanceAdvanced, 
	TransitionParameter:= ADR (_TransitionParam), 
	TransitionParameterCount:= 2, 
	InvokeId:= 10, // TODO should increment this with each additional call made here if calls are added
	DynamicConstraints:= , 
	Error=> , 
	ErrorId=> );
_MovePrepError := _MovePrepError OR _MC_MoveCircularAbsolutePreparation.Error;]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_AddLinAbsPath" Id="{f006f2c9-a0b4-42c7-9dc4-82f2ba9cc8ec}" FolderPath="PathPlanning\">
      <Implementation>
        <ST><![CDATA[_MovePrepError := FALSE;
_path.ClearPath();  //Clear nodes that were in path

_MC_MoveLinearAbsolutePreparation.Position						:= ADR(_TargetPos); //pointer to position array
_MC_MoveLinearAbsolutePreparation.PositionCount 				:= _NumberOfAxes; //number of axes in group
_MC_MoveLinearAbsolutePreparation.TransitionParameter			:= ADR (_TransitionParam); //pointer to transition parameter array
_MC_MoveLinearAbsolutePreparation.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
_MC_MoveLinearAbsolutePreparation.BufferMode					:= mcBlendingPrevious;
_MC_MoveLinearAbsolutePreparation.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
//Set dynamics to default values of the axes
_MC_MoveLinearAbsolutePreparation.Acceleration					:= MC_DEFAULT;
_MC_MoveLinearAbsolutePreparation.Deceleration					:= MC_DEFAULT;
_MC_MoveLinearAbsolutePreparation.Jerk							:= MC_DEFAULT;

//
CASE _MoveCommandParser.stCommand.CoordSystem OF
	DUT_CoordSystem.ACS:
		_CoordRef := GVL.McsCoordRef; // TODO: we shouldnt be here. maybe fault?
	DUT_CoordSystem.MCS:
		_CoordRef := GVL.McsCoordRef;
	DUT_CoordSystem.UCS1:
		_CoordRef := GVL.Ucs1CoordRef;
	DUT_CoordSystem.UCS2:
		_CoordRef := GVL.Ucs2CoordRef;
	DUT_CoordSystem.TCP:
		_CoordRef := GVL.TcpCoordRef;
END_CASE
_MC_SetCoordinateTransformPreparation(PathData:=_path, CoordTransform:=_CoordRef);
_MovePrepError := _MovePrepError OR _MC_SetCoordinateTransformPreparation.Error;

//1st node
_TargetPos[1]				:= _PosRef.X;
_TargetPos[2]				:= _PosRef.Y;
_TargetPos[3]				:= _PosRef.Z;
// _TargetPos[4]				:= GroupHandler.P_GroupStatus.CurrentPosition.A + _PosRef.A;
// _TargetPos[5]				:= GroupHandler.P_GroupStatus.CurrentPosition.B + _PosRef.B;
// _TargetPos[6]				:= GroupHandler.P_GroupStatus.CurrentPosition.C + _PosRef.C;
_TargetPos[4]				:= _PosRef.A;
_TargetPos[5]				:= _PosRef.B;
_TargetPos[6]				:= _PosRef.C;
_TransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
_TransitionParam[2]			:= 0; //blending distance on this segment, no influence here
_MC_MoveLinearAbsolutePreparation(	PathData:= _path,
									Velocity:= _MoveCommandParser.stCommand.Speed, 
									InvokeId:= 10); // TODO should increment this with each additional call made here if calls are added
_MovePrepError := _MovePrepError OR _MC_MoveLinearAbsolutePreparation.Error;]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_AddLinRelPath" Id="{64a947aa-392e-470b-afeb-6e7291acf475}" FolderPath="PathPlanning\">
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Action>
    <Method Name="M_Aborting" Id="{4e26ece5-3a6a-4b95-a5a2-0147c1e26a3d}">
      <Declaration><![CDATA[METHOD PROTECTED M_Aborting : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE _SeqAborting OF
	0:
		GroupHandler.M_DisableGroup();
		_SeqAborting := _SeqAborting + 1;
	1:
		IF NOT GroupHandler.P_GroupEnabled THEN
			SUPER^.M_StateComplete();
			_SeqAborting := 0;
		END_IF
		
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Clearing" Id="{2e7feb23-d083-4537-94b3-cdf41be2bdfa}">
      <Declaration><![CDATA[METHOD PROTECTED M_Clearing : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
_MC_MovePath.Execute := FALSE;
_SequenceMoveCircularAbsolute := 0;
_SequenceMoveCircularRelative := 0;
_SequenceMoveDirectAbsolute := 0;
_SequenceMoveDirectRelative := 0;
_SequenceMoveLinearAbsolute := 0;
_SequenceMoveLinearRelative := 0;
_SequenceSetCoordTrans := 0;

SUPER^.M_StateComplete();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Complete" Id="{5915b6b9-5c4b-4cff-a92a-a70dfd02e351}">
      <Declaration><![CDATA[METHOD PROTECTED M_Complete : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// once complete, reset to get back to idle
SUPER^._UnitMode.Reset();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Execute" Id="{a682ac1d-71f4-44e2-9664-b97db23d1386}">
      <Declaration><![CDATA[METHOD PROTECTED M_Execute : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// here we want to execute our commands/jobs/etc and set completed when done.
IF SUPER^._SeqMain =_STEP_IDLE THEN
	SUPER^.M_StateComplete();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Holding" Id="{67eb5664-2a5b-4455-8b32-aeda1b99b743}">
      <Declaration><![CDATA[METHOD PROTECTED M_Holding : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE SUPER^._SeqHolding OF
	0:
		_MC_MovePath.Execute := FALSE;
		_MC_GroupHalt.Execute:=TRUE;
		_SeqHolding := _SeqHolding + 1;
	1:
		IF _MC_GroupHalt.Done THEN
			_MC_GroupHalt.Execute := FALSE;
			SUPER^.M_StateComplete();
			_SeqHolding := 0;
		END_IF
		
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Idle" Id="{387dbba7-203a-4514-9198-3038b8e4b5dc}">
      <Declaration><![CDATA[METHOD PROTECTED M_Idle : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// in this state, we want to reset all the function blocks and hang out

_MC_MovePath.Execute := FALSE;
_SequenceMoveCircularAbsolute := 0;
_SequenceMoveCircularRelative := 0;
_SequenceMoveDirectAbsolute := 0;
_SequenceMoveDirectRelative := 0;
_SequenceMoveLinearAbsolute := 0;
_SequenceMoveLinearRelative := 0;
_SequenceSetCoordTrans := 0;
SUPER^._SeqMain := 0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Resetting" Id="{95f46e6e-26ec-450c-948d-d902314a1d4d}">
      <Declaration><![CDATA[METHOD PROTECTED M_Resetting : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE SUPER^._SeqResetting OF
	0:
		GroupHandler.M_ResetGroup();
		SUPER^._SeqResetting := SUPER^._SeqResetting + 1;
	1:
		IF GroupHandler.Busy THEN
			SUPER^._SeqResetting := SUPER^._SeqResetting + 1;
		END_IF
	2:
		IF NOT GroupHandler.Busy THEN
			SUPER^.M_StateComplete();
			SUPER^._SeqResetting := 0;
		END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_SetPackML" Id="{09bb9e0c-557b-4db9-8574-c3a1036b476e}">
      <Declaration><![CDATA[METHOD PROTECTED M_SetPackML : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^._UnitMode(	sName := 'Move Processor',
				eInitialState := PACK_ML.State.Idle,
				xActive := TRUE);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Starting" Id="{ce3be291-42fd-4d66-9e0a-0e5bf023807b}">
      <Declaration><![CDATA[METHOD PROTECTED M_Starting : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// here we want to clear things and get ready for the execute state
// I can consider this the "INIT" state
SUPER^._SeqMain := _STEP_COMMAND;
SUPER^.M_StateComplete();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_UnHolding" Id="{388ca3d8-559e-4364-ae71-180c399a068a}">
      <Declaration><![CDATA[METHOD PROTECTED M_UnHolding : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// here the operator called unhold (most likely from M_Start)
_MC_GroupHalt.Execute := FALSE;
_MC_MovePath.Execute := TRUE;
CASE _MoveCommandParser.stCommand.MoveType OF 
	DUT_Command_MoveType.DirectMove:
		IF _MoveCommandParser.stCommand.PositionType = DUT_Command_Positiontype.AbsolutePosition THEN
			//_MC_MoveDirectAbsolute.Execute := TRUE;
		ELSE
			//_MC_MoveDirectRelative.Execute := TRUE;
		END_IF
	DUT_Command_MoveType.LinearMove:
		IF _MoveCommandParser.stCommand.PositionType = DUT_Command_Positiontype.AbsolutePosition THEN
			//_MC_MoveLinearAbsolute.Execute := TRUE;
		ELSE
			//_MC_MoveLinearRelative.Execute := TRUE;
		END_IF
	DUT_Command_MoveType.CircularMove:
		IF _MoveCommandParser.stCommand.PositionType = DUT_Command_Positiontype.AbsolutePosition THEN
			//_MC_MoveCircularAbsolute.Execute := TRUE;
		ELSE
			//_MC_MoveCircularRelative.Execute := TRUE;
		END_IF
END_CASE
//
SUPER^.M_StateComplete();]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>