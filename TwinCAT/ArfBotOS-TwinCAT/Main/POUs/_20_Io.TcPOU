<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="_20_Io" Id="{c3b19a06-6020-44bc-8c83-cb31670bfa1a}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM _20_Io
VAR
	PowerOn: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//
PowerOn := GVL.PowerOn;

//
_M_HandleRemoteIO();]]></ST>
    </Implementation>
    <Method Name="_M_HandleRemoteIO" Id="{95e27eb3-1cc7-4783-8f9f-46fca05a221d}">
      <Declaration><![CDATA[METHOD PRIVATE _M_HandleRemoteIO
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//
HeartbeatOn(in:=NOT HeartbeatOff.Q,PT:=HeartbeatPt);
HeartbeatOff(in:=HeartbeatOn.Q,PT:=HeartbeatPt);

// need to use system time to transfer faster than 1ms
SysLTime := LTIME();
IF SysLTime - SysLTimeLast > TransferTime THEN
	SysLTimeLast := SysLTime;
	TransferTrigger := NOT TransferTrigger;
END_IF

// handle outputs
// index 0 is for system outputs
pabyTxBuffer[0].0:=HeartbeatOn.Q; 	// heartbeat
pabyTxBuffer[0].1:=GVL.PowerOn; 			// enable
// pabyTxBuffer[0].2:=;
// pabyTxBuffer[0].3:=;
// pabyTxBuffer[0].4:=;
// pabyTxBuffer[0].5:=;
// pabyTxBuffer[0].6:=;
// pabyTxBuffer[0].7:=;

//
pabyTxBuffer[1].0 := GVL.CmdIO.Output[4];
pabyTxBuffer[1].1 := GVL.CmdIO.Output[5];
pabyTxBuffer[1].2 := GVL.CmdIO.Output[6];
pabyTxBuffer[1].3 := GVL.CmdIO.Output[7];
//pabyTxBuffer[1].4 := ;
//pabyTxBuffer[1].5 := ;
//pabyTxBuffer[1].6 := ;
//pabyTxBuffer[1].7 := ;

//
pabyTxBuffer[2] := GVL.CmdIO.Pwm[0];
pabyTxBuffer[3] := GVL.CmdIO.Pwm[1];
pabyTxBuffer[4] := GVL.CmdIO.Pwm[2];
pabyTxBuffer[5] := GVL.CmdIO.Pwm[3];

// Tx buffer index 30 and 31 will be for crc
// calc crc here
TxCrc := F_Checksum(ADR(pabyTxBuffer), 30);
// append calc crc to tx buffer
MEMUtils.MemCpy(pbyDest:=ADR(pabyTxBuffer[30]), 
				pbySrc:=ADR(TxCrc), 
				dwSize:=2);

// read and write to i2c bus
//IF TransferTrigger THEN
	(*I2C_master_Bus2.write(usiAddress:=i2caddress,
					pbyBuffer:=ADR(pabyTxBuffer),
					nBufferLen:=transferlentx);
	I2C_master_Bus2.read(usiAddress:=i2caddress,
					pbyBuffer:=ADR(pabyRxBuffer),
					nBufferLen:=transferlenrx);*)
//END_IF

// copy crc from rx buffer
MEMUtils.MemCpy(pbyDest:=ADR(RxCrc), 
				pbySrc:=ADR(pabyRxBuffer[30]), 
				dwSize:=2);

// compare calc crc with rx crc
IF RxCrc = F_Checksum(ADR(pabyRxBuffer), 30) THEN
	// handle inputs
	// index 0 is for system inputs
	rx_heartbeat 		:= pabyRxBuffer[0].0;
	rx_en 				:= pabyRxBuffer[0].1;
	//rx_   			:= pabyRxBuffer[0].2;
	//rx_ 				:= pabyRxBuffer[0].3;
	//rx_ 				:= pabyRxBuffer[0].4;
	//rx_ 				:= pabyRxBuffer[0].5;
	//rx_ 				:= pabyRxBuffer[0].6;
	//rx_ 				:= pabyRxBuffer[0].7;
	
	// index 1 will be for gpio byte (bits 0 through 7)
	GVL.CmdIO.Input[4] := pabyRxBuffer[1].0;
	GVL.CmdIO.Input[5] := pabyRxBuffer[1].1;
	GVL.CmdIO.Input[6] := pabyRxBuffer[1].2;
	GVL.CmdIO.Input[7] := pabyRxBuffer[1].3;
	// := pabyRxBuffer[1].4;
	// := pabyRxBuffer[1].5;
	// := pabyRxBuffer[1].6;
	// := pabyRxBuffer[1].7;
	
ELSE
	// increment crc mismatch counter
	ChecksumMisCount := ChecksumMisCount + 1;
END_IF]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>