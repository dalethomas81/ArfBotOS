<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="_00_Main" Id="{f495872a-eb99-4e62-a111-ca71535b5152}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM _00_Main
VAR CONSTANT
	NumberOfAxes: UINT:=6;
END_VAR
VAR
	
	//
	fbWritePersistentData: FB_WritePersistentData;
	
	//
	TimingBits1Timer: TON;
	
	// group handler for all motion fbs
    // https://infosys.beckhoff.com/content/1033/tf5420_tc3_advanced_pick_and_place/8893733771.html?id=5942709046194342427
	GroupHandler: FB_GroupHandler;
	fbGroupSetOvr: MC_GroupSetOverride;
	GroupVelocityFactor: LREAL:=0.75;
    stAxesConfig: ST_KinAxes;
    stGroupRef : AXES_GROUP_REF;
	ACS: ARRAY[1..NumberOfAxes] OF AXIS_REF;
	MCS: ARRAY[1..NumberOfAxes] OF AXIS_REF;
	
	// tuning
	//MoveDistance: LREAL := 5.0;
	//MoveRelative: ARRAY[0..5] OF MC_MoveRelative;
	//TuneStart: ARRAY[0..5] OF BOOL;
	//TraceStart: ARRAY[0..5] OF BOOL;
	//TraceStop: ARRAY[0..5] OF BOOL;
	//SetTuningMoveValues: BOOL:=TRUE;
	
	// homing
	ProcessHome: FB_HomingProcessor;
	HomingStatusText: STRING(255);
	
	// jogging
	ProcessJog: FB_JogProcessor;
	JogStatusText: STRING(255);
	//ButtonTextIndex: INT:=0;
	
	// program processor
	ProcessPrograms: FB_ProgramProcessor;
	ProcessCommand_ActiveProgram: UINT := 0;
	ActiveCommandDetails: STRING(255):='';
	
	// devices
	//Controller: FB_Controller;
	Gripper: FB_DigitalOutput;
	Laser: FB_DigitalOutput;
	Smoke: FB_DigitalOutput;
	Beeper: FB_DigitalOutput;
	Beacon: FB_DigitalOutput;
	
	// hello world
	buffer: ARRAY[1..4096] OF BYTE;
	
	//
	_i, _j, _k: UINT;
	BuildTests: BOOL:=FALSE;
	FirstScan: BOOL:=TRUE;
	
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
{region "utility"}
	GVL.ResetRtrig(CLK:=GVL.Reset);
	IF GVL.ResetRtrig.Q THEN
		GVL.Reset := FALSE;
	END_IF
	
	IF FirstScan THEN
		M_Init();	
	END_IF
	
	IF BuildTests THEN
		BuildTests := FALSE;
		M_BuildTests();
	END_IF
	
	// https://infosys.beckhoff.com/content/1033/tcplclib_tc2_utilities/35030155.html?id=118377046089916014
	fbWritePersistentData(
		NETID:= '', 
		PORT:= 851, 
		START:= GVL.StorePersist, 
		TMOUT:= T#1S, 
		MODE:= E_PersistentMode.SPDM_2PASS, 
		BUSY=> , 
		ERR=> , 
		ERRID=> );
	GVL.StorePersist := FALSE;
	
	//
	GVL.BlinkingBitsTimer(IN:=TRUE, PT:=GVL.BlinkingBitsTimerTime);
	IF GVL.BlinkingBitsTimer.Q THEN
		GVL.BlinkingBitsTimer(IN:=FALSE);
		GVL.BlinkingBitsTime:=GVL.BlinkingBitsTime+1;
	END_IF
{endregion}
     
{region "methods"}
	_M_SpookyHalloween();
	//_M_HelloWorld();
	_M_GroupHandler();
    //_M_Jogging();
    _M_Homing();
    //_M_Processor();
	_M_Devices();
	//_M_Tuning();
{endregion}

// do not put anything below this
FirstScan:=FALSE;]]></ST>
    </Implementation>
    <Method Name="_M_Devices" Id="{111d7557-61e1-48d4-ad0f-48b4ac517334}">
      <Declaration><![CDATA[METHOD PRIVATE _M_Devices : BOOL
VAR_INPUT
END_VAR
VAR_STAT
	_PowerRtrig: R_TRIG;
	_PowerFtrig: F_TRIG;
	_PowerTimerRtrig: R_TRIG;
	_PowerTimer: TON:=(PT:=T#1S);
	_PsButtonRtrig: R_TRIG;
	_PsButtonFtrig: F_TRIG;
	_PsButtonTimer: TON:=(PT:=T#2S);
	_PsButtonTimerRtrig: R_TRIG;
	_Reseting: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//
Gripper();
Laser();
Smoke();
Beeper();
Beacon();

(*
// dont get sleepy
Controller(sIpAddress:= '127.0.0.1', uPort:= 50013);

// put two fingers on the trackpad for 3 seconds to toggle power
_PowerTimer(IN:=Controller.P_State.Connected
				AND Controller.P_State.Buttons.Touch
				AND Controller.P_State.Trackpads.One.Active 
				AND Controller.P_State.Trackpads.Two.Active);
_PowerTimerRtrig(CLK:=_PowerTimer.Q);
IF _PowerTimerRtrig.Q THEN
	GVL.PowerOn := NOT GVL.PowerOn;
END_IF
_PowerRtrig(CLK:=GVL.PowerOn);
_PowerFtrig(CLK:=GVL.PowerOn);
IF _PowerRtrig.Q OR _PowerFtrig.Q THEN
	IF GVL.PowerOn THEN
		Controller.M_SetColor(255,0,0);
		Controller.M_SetBrightness(E_ControllerBrightness.High);
		Controller.M_SetMotorIntensity(E_ControllerMotor.Left, 100, 0.100);
	ELSE
		Controller.M_SetColor(0,255,0);
		Controller.M_SetBrightness(E_ControllerBrightness.Low);
		Controller.M_SetMotorIntensity(E_ControllerMotor.Right, 100, 0.100);
	END_IF
END_IF

// press PS button once to reset
_PsButtonRtrig(CLK:=Controller.P_State.Buttons.PS);
_PsButtonFtrig(CLK:=Controller.P_State.Buttons.PS);
IF _PsButtonRtrig.Q THEN
	_Reseting := TRUE;
END_IF
IF _PsButtonFtrig.Q THEN
	IF _Reseting THEN //  reset was not overridden by holding it down too long
		_Reseting := FALSE;
		GVL.Reset := TRUE;
	END_IF
END_IF

// hold down the PS button to home
_PsButtonTimer(IN:=Controller.P_State.Buttons.PS);
_PsButtonTimerRtrig(CLK:=_PsButtonTimer.Q);
IF _PsButtonTimerRtrig.Q THEN
	_Reseting := FALSE; // ps button was held down too long so we dont reset
	ProcessHome.M_StartHoming();
END_IF
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_GroupHandler" Id="{39e1494b-f21b-4425-b5e3-86e0f472492e}">
      <Declaration><![CDATA[METHOD PRIVATE _M_GroupHandler : BOOL
VAR_STAT
	ResetGroup: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// set the group velocity factor
fbGroupSetOvr(
	AxesGroup:= stGroupRef, 
	Enable:= TRUE, 
	VelFactor:= GroupVelocityFactor , 
	Enabled=> , 
	Busy=> , 
	Error=> , 
	ErrorId=> , 
	ActualVelFactor=> );
IF fbGroupSetOvr.Error THEN
	//
END_IF

// handle all the group specific actions
GroupHandler(
	AxisGroup:= stGroupRef, 
	ACS:= ACS, 
	MCS:= MCS, 
	Enable:= GVL.PowerOn, 
	StoredPositions:= PersistentVars.StoredPositions, 
	Busy=> , 
	Error=> , 
	ErrorID=> );
	
IF ResetGroup THEN
	ResetGroup := FALSE;
	GroupHandler.M_ResetGroup();
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_HelloWorld" Id="{6c29bf60-c389-45f0-9c5a-a3e11fdbd34e}">
      <Declaration><![CDATA[METHOD _M_HelloWorld
VAR_INPUT
END_VAR
VAR_STAT
	Velocity: LREAL:=10.0;
	SeqHelloWorld: INT:=0;
	HelloWorldStart: BOOL;
	mcMoveRelativeAcs: ARRAY[1..NumberOfAxes] OF MC_MoveRelative;
	mcMoveRelativeMcs: ARRAY[1..NumberOfAxes] OF MC_MoveRelative;
	MoveDistanceAcs: ARRAY[1..NumberOfAxes] OF LREAL:=[0,0,0,0,0,10];
	MoveDistanceMcs: ARRAY[1..NumberOfAxes] OF LREAL:=[10,0,0,0,0,0];
	mcMoveAbsoluteAcs: ARRAY[1..NumberOfAxes] OF MC_MoveAbsolute;
	mcMoveAbsoluteMcs: ARRAY[1..NumberOfAxes] OF MC_MoveAbsolute;
	MovePositionAcs: ARRAY[1..NumberOfAxes] OF LREAL:=[0,-15,115,0,-30,0];
	MovePositionMcs: ARRAY[1..NumberOfAxes] OF LREAL:=[300,0,415,0,90,0];
	AcsMoveRelative, AcsMoveAbsolute: BOOL;
	McsMoveRelative, McsMoveAbsolute: BOOL;
	SeqSetTransform: INT;
	TcpCoordinateFrame: FB_CoordinateFrame;
	offsetFrame: DUT_CoordFrame;
	SetTcpOffset: BOOL;
	TcpSet: BOOL;
	mcSetCoordinateTransform: MC_SetCoordinateTransform;
	TcpMode: BOOL;
	EnableAcs, EnableMcs, EnableTcp, DisableGroup, ResetGroup: BOOL;
	path: MC_PATH_DATA_REF(ADR(buffer), SIZEOF(buffer));
    fbMoveLinPrep: MC_MoveLinearAbsolutePreparation;
	fbSetCoordTransPrep: MC_SetCoordinateTransformPreparation;
    aTargetPos: ARRAY[1..NumberOfAxes] OF MC_LREAL;
    aTransitionParam: ARRAY[1..2] OF MC_LREAL;
    bMovePrepError: BOOL;
    fbMovePath: MC_MovePath;
	fbBlockerPreparation: MC_BlockerPreparation;
	fbReleaseBlocker: MC_ReleaseBlocker;
	fbGroupReadBlockerStatus: MC_GroupReadBlockerStatus;
	ToggleGripper: BOOL;
	
	AddPaths, AddPathsTcp: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// twincat hello world

// https://docs.google.com/spreadsheets/d/1S5TOxwbAx8pTMUdoWMnyC9WPfphhtUME/edit#gid=595805457

// drive process image
// https://infosys.beckhoff.com/content/1033/tf50x0_tc3_nc_ptp/10650598155.html?id=428682353028589629

// axis process image
// https://infosys.beckhoff.com/content/1033/tf50x0_tc3_nc_ptp/10650582539.html?id=9197998846476281621

// separate file is needed when using L4 Kinematics transformation (6 Axis)
// https://infosys.beckhoff.com/content/1033/tf5400_tc3_advanced_motion_pack/8403043979.html?id=9115801577672301435

// use these to manage the group manually while testing.
// if things get out of wack, you can always reset, disable, then reset and all will be well again
IF ResetGroup THEN
	ResetGroup := FALSE;
	GroupHandler.M_ResetGroup();
END_IF
IF EnableAcs THEN
	EnableAcs := FALSE;
	GroupHandler.M_EnableGroup(DUT_CoordSystem.ACS);
END_IF
IF EnableMcs THEN
	EnableMcs := FALSE;
	GroupHandler.M_EnableGroup(DUT_CoordSystem.MCS);
END_IF
IF EnableTcp THEN
	EnableTcp := FALSE;
	GroupHandler.M_EnableGroup(DUT_CoordSystem.TCP);
END_IF
IF DisableGroup THEN
	DisableGroup := FALSE;
	GroupHandler.M_DisableGroup();
END_IF
IF ToggleGripper THEN
	ToggleGripper := FALSE;
	Gripper.Toggle();
END_IF

// set the HelloWorldStart variable to run the hello world moves.
// the TcpMode variable will test the TCP relative move. otherwise, the moves will be absolute the MCS
TcpMode := TcpMode;
HelloWorldStart := HelloWorldStart;
CASE SeqHelloWorld OF
		
	0: // idle
		IF HelloWorldStart THEN
			HelloWorldStart := FALSE;
			GVL.PowerOn := TRUE;
			bMovePrepError := FALSE;
			Gripper.Off(); // open the gripper
			SeqHelloWorld := SeqHelloWorld + 1;
		END_IF
		
	1: // enable group
		IF GroupHandler.M_EnableGroup(SEL(TcpMode, DUT_CoordSystem.MCS, DUT_CoordSystem.TCP)) THEN
 			SeqHelloWorld := SeqHelloWorld + 1;
		END_IF
		
	2: // wait on group enable
		IF GroupHandler.P_GroupReady THEN
 			SeqHelloWorld := SeqHelloWorld + 1;
		END_IF
		
	3: // add paths
		IF TcpMode THEN AddPathsTcp:=TRUE; ELSE AddPaths:=TRUE; END_IF
		IF NOT bMovePrepError THEN
			fbMovePath.Execute:=FALSE;
			fbReleaseBlocker.Execute:=FALSE;
			SeqHelloWorld := SeqHelloWorld + 1;
		END_IF
		
	4: // move
		fbMovePath.Execute := TRUE;
		// wait for gripper position
		IF fbGroupReadBlockerStatus.Blocked AND fbGroupReadBlockerStatus.BlockerId = 100 THEN
			SeqHelloWorld := SeqHelloWorld + 1;
		ELSIF TcpMode THEN // no blocker is set for TcpMode
			SeqHelloWorld := SeqHelloWorld + 2;
		END_IF
		
	5: // close the gripper and release the blocker
		Gripper.On();
		fbReleaseBlocker.Execute:=TRUE;
		SeqHelloWorld := SeqHelloWorld + 1;
		
	6:
		// wait for motion to be done
		IF fbMovePath.Done THEN
			fbMovePath.Execute:=FALSE;
			SeqHelloWorld := SeqHelloWorld + 1;
		ELSIF fbMovePath.Error THEN
			//	
		END_IF
		
	7: // disable group
		GroupHandler.M_DisableGroup();
		SeqHelloWorld := SeqHelloWorld + 1;
	
	8:  // wait on group disable
		IF NOT GroupHandler.P_GroupReady THEN
 			SeqHelloWorld := 0;
		END_IF
		
	1000..9999:
		;//Error	
	
END_CASE

fbMovePath(
	AxesGroup:= stGroupRef, 
	PathData:= path, 
	Execute:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorId=> );

fbGroupReadBlockerStatus(
	AxesGroup:= stGroupRef, 
	Enable:= TRUE, 
	Valid=> , 
	Blocked=> , 
	BlockerId=> );

fbReleaseBlocker(
	AxesGroup:= stGroupRef, 
	Execute:= , 
	BlockerId:= 100, 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorId=> );

CASE SeqSetTransform OF
	0: 
		IF SetTcpOffset THEN
			SetTcpOffset := FALSE;
			TcpSet := FALSE;
			SeqSetTransform := SeqSetTransform + 1;
		END_IF
		
	1:
		offsetFrame.Position.X := MCS[1].NcToPlc.ActPos + PersistentVars.StoredPositions[GVL.TCP_POS_IDX].Position.X;
		offsetFrame.Position.Y := MCS[2].NcToPlc.ActPos + PersistentVars.StoredPositions[GVL.TCP_POS_IDX].Position.Y;
		offsetFrame.Position.Z := MCS[3].NcToPlc.ActPos + PersistentVars.StoredPositions[GVL.TCP_POS_IDX].Position.Z;
		offsetFrame.Position.A := MCS[4].NcToPlc.ActPos + PersistentVars.StoredPositions[GVL.TCP_POS_IDX].Position.A;
		offsetFrame.Position.B := MCS[5].NcToPlc.ActPos + PersistentVars.StoredPositions[GVL.TCP_POS_IDX].Position.B;
		offsetFrame.Position.C := MCS[6].NcToPlc.ActPos + PersistentVars.StoredPositions[GVL.TCP_POS_IDX].Position.C;
		offsetFrame.Interpretation := MC.CoordInterpretation_SO3.Rotation_Z3Y2X1_DIN9300;
		offsetFrame.Direction := MC.ReferenceDefDir.fromReference;
		TcpCoordinateFrame.Execute := TRUE;
		SeqSetTransform := SeqSetTransform + 1;
		
	2:
		IF TcpCoordinateFrame.Done THEN
			TcpCoordinateFrame.Execute := FALSE;
			TcpSet := TRUE;
			SeqSetTransform := 0;
		END_IF
		
END_CASE

//
TcpCoordinateFrame(
	Execute:= , 
	oidTrafo:= gvl.TcpCoordRef, 
	OffsetFrame:= offsetFrame, 
	Done=> , 
	Busy=> , 
	Error=> );


// the below tests show how to use mc fbs to control the acs and mcs axes directly.
// you will still need to use the fb_grouphandler for these

// move relative
// need to call the group handler with parameter ACS first
FOR _k:= 1 TO NumberOfAxes DO
	mcMoveRelativeAcs[_k](
		Axis:= ACS[_k], 
		Execute:= AcsMoveRelative, 
		Distance:= MoveDistanceAcs[_k], 
		Velocity:= Velocity, 
		Acceleration:= 1000, 
		Deceleration:= 1000, 
		Jerk:= 100, 
		BufferMode:= , 
		Options:= , 
		Done=> , 
		Busy=> , 
		Active=> , 
		CommandAborted=> , 
		Error=> , 
		ErrorID=> );
END_FOR
// NOT CURRENTLY WORKING AS INTENDED
// need to call the group handler with parameter MCS first
// FOR _k:= 1 TO NumberOfAxes DO
// 	mcMoveRelativeMcs[_k](
// 		Axis:= MCS[_k], 
// 		Execute:= McsMoveRelative, 
// 		Distance:= MoveDistanceMcs[_k], 
// 		Velocity:= Velocity, 
// 		Acceleration:= 1000, 
// 		Deceleration:= 1000, 
// 		Jerk:= 100, 
// 		BufferMode:= , 
// 		Options:= , 
// 		Done=> , 
// 		Busy=> , 
// 		Active=> , 
// 		CommandAborted=> , 
// 		Error=> , 
// 		ErrorID=> );
// END_FOR

// move absolute
// need to call the group handler with parameter ACS first
FOR _k:= 1 TO NumberOfAxes DO
	mcMoveAbsoluteAcs[_k](
		Axis:= ACS[_k], 
		Execute:= AcsMoveAbsolute, 
		Position:= MovePositionAcs[_k], 
		Velocity:= Velocity, 
		Acceleration:= 1000, 
		Deceleration:= 1000, 
		Jerk:= 100, 
		BufferMode:= , 
		Options:= , 
		Done=> , 
		Busy=> , 
		Active=> , 
		CommandAborted=> , 
		Error=> , 
		ErrorID=> );
END_FOR
// NOT CURRENTLY WORKING AS INTENDED
// need to call the group handler with parameter MCS first
// FOR _k:= 1 TO NumberOfAxes DO
// 	mcMoveAbsoluteMcs[_k](
// 		Axis:= MCS[_k], 
// 		Execute:= McsMoveAbsolute, 
// 		Position:= MovePositionMcs[_k], 
// 		Velocity:= Velocity, 
// 		Acceleration:= 1000, 
// 		Deceleration:= 1000, 
// 		Jerk:= 100, 
// 		BufferMode:= , 
// 		Options:= , 
// 		Done=> , 
// 		Busy=> , 
// 		Active=> , 
// 		CommandAborted=> , 
// 		Error=> , 
// 		ErrorID=> );
// END_FOR

{regions 'add paths'}
IF AddPaths THEN
	AddPaths := FALSE;
	
	path.ClearPath();  //Clear nodes that were in path

	fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
	fbMoveLinPrep.PositionCount 				:= NumberOfAxes; //number of axes in group
	fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
	fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
	fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
	fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
	//Set dynamics to default values of the axes
	fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
	fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
	fbMoveLinPrep.Jerk							:= 100.0;//MC_DEFAULT;
	
	// set mcs frame
	fbSetCoordTransPrep(PathData:=path, CoordTransform:=GVL.McsCoordRef);
	bMovePrepError := bMovePrepError OR fbSetCoordTransPrep.Error;
	
	// 1st node
	aTargetPos[1]				:= 300;
	aTargetPos[2]				:= 0;
	aTargetPos[3]				:= 415;
	aTargetPos[4]				:= 0;
	aTargetPos[5]				:= 90;
	aTargetPos[6]				:= 0;
	aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
	aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
	fbMoveLinPrep(PathData:= path , Velocity:= 20, InvokeId:= 10);
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
	
	aTargetPos[1]				:= 310;
	aTargetPos[2]				:= 10;
	aTargetPos[3]				:= 400;
	aTargetPos[4]				:= 0;
	aTargetPos[5]				:= 70;
	aTargetPos[6]				:= 0;
	aTransitionParam[1]			:= 5;//200; //blending distance on previous segment (InvokeId=10), defines when to leave line
	aTransitionParam[2]			:= 5;//2400; //blending distance on this segment, defines latest positionn to be back  on line of InovkeId=20 
	fbMoveLinPrep(PathData:= path , Velocity:= 20, InvokeId:= 20); 
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
	
	aTargetPos[1]				:= 300;
	aTargetPos[2]				:= 0;
	aTargetPos[3]				:= 415;
	aTargetPos[4]				:= 0;
	aTargetPos[5]				:= 80;
	aTargetPos[6]				:= 0;
	aTransitionParam[1]			:= 5;//2250; 
	aTransitionParam[2]			:= 5;//2250;
	fbMoveLinPrep(PathData:= path , Velocity:= 20, InvokeId:= 30);
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
	
	// example of how to add a blocker to the path data
	fbBlockerPreparation(
		PathData:= path, 
		BlockerId:= 100, // blocker id is unique
		BufferMode:= mcBuffered, 
		InvokeId:= 40, 
		Error=> , 
		ErrorId=> );
	
	//1st node
	aTargetPos[1]				:= 300;
	aTargetPos[2]				:= 0;
	aTargetPos[3]				:= 415;
	aTargetPos[4]				:= 0.0;
	aTargetPos[5]				:= 80.0;
	aTargetPos[6]				:= 5.0;
	aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
	aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
	fbMoveLinPrep(PathData:= path , Velocity:= 5, InvokeId:= 50);
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
	
	//1st node
	aTargetPos[1]				:= 300;
	aTargetPos[2]				:= 0;
	aTargetPos[3]				:= 415;
	aTargetPos[4]				:= 0.0;
	aTargetPos[5]				:= 80.0;
	aTargetPos[6]				:= -5.0;
	aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
	aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
	fbMoveLinPrep(PathData:= path , Velocity:= 5, InvokeId:= 60);
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
	
	//1st node
	aTargetPos[1]				:= 300;
	aTargetPos[2]				:= 0;
	aTargetPos[3]				:= 415;
	aTargetPos[4]				:= 0.0;
	aTargetPos[5]				:= 80.0;
	aTargetPos[6]				:= 0.0;
	aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
	aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
	fbMoveLinPrep(PathData:= path , Velocity:= 5, InvokeId:= 70);
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
	
	//1st node
	aTargetPos[1]				:= 300;
	aTargetPos[2]				:= 0;
	aTargetPos[3]				:= 415;
	aTargetPos[4]				:= 0.0;
	aTargetPos[5]				:= 80.0 + 10.0;
	aTargetPos[6]				:= 0.0;
	aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
	aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
	fbMoveLinPrep(PathData:= path , Velocity:= 5, InvokeId:= 80);
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
	
	//1st node
	aTargetPos[1]				:= 300;
	aTargetPos[2]				:= 0;
	aTargetPos[3]				:= 415;
	aTargetPos[4]				:= 0.0;
	aTargetPos[5]				:= 80.0 - 10.0;
	aTargetPos[6]				:= 0.0;
	aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
	aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
	fbMoveLinPrep(PathData:= path , Velocity:= 5, InvokeId:= 90);
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
	
	//1st node
	aTargetPos[1]				:= 300;
	aTargetPos[2]				:= 0;
	aTargetPos[3]				:= 415;
	aTargetPos[4]				:= 0.0;
	aTargetPos[5]				:= 80.0;
	aTargetPos[6]				:= 0.0;
	aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
	aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
	fbMoveLinPrep(PathData:= path , Velocity:= 5, InvokeId:= 90);
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
END_IF
{endregion}

{region 'add paths tcp'}
IF AddPathsTcp THEN
	AddPathsTcp := FALSE;
	
	path.ClearPath();  //Clear nodes that were in path

	fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
	fbMoveLinPrep.PositionCount 				:= NumberOfAxes; //number of axes in group
	fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
	fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
	fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
	fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
	//Set dynamics to default values of the axes
	fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
	fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
	fbMoveLinPrep.Jerk							:= MC_DEFAULT;
	
	//
	fbSetCoordTransPrep(PathData:=path, CoordTransform:=GVL.TcpCoordRef);
	bMovePrepError := bMovePrepError OR fbSetCoordTransPrep.Error;
	
	//1st node
	aTargetPos[1]				:= 0;
	aTargetPos[2]				:= 0;
	aTargetPos[3]				:= 10;
	aTargetPos[4]				:= mcs[4].NcToPlc.ActPos + 0.0;
	aTargetPos[5]				:= mcs[5].NcToPlc.ActPos + 0.0;
	aTargetPos[6]				:= mcs[6].NcToPlc.ActPos + 0.0;
	aTransitionParam[1]			:= 0; //blending distance on previous segment, no influence here
	aTransitionParam[2]			:= 0; //blending distance on this segment, no influence here
	fbMoveLinPrep(PathData:= path , Velocity:= 10, InvokeId:= 10);
	bMovePrepError := bMovePrepError OR fbMoveLinPrep.Error;
END_IF
{endregion}]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_Homing" Id="{bf4b7640-1df3-46ff-b6ca-dc416adad7e8}">
      <Declaration><![CDATA[METHOD PRIVATE _M_Homing : BOOL
VAR_STAT
	SetHome: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
ProcessHome(
	ACS:= ACS, 
	AxisGroup:= stGroupRef, 
	GroupHandler:= GroupHandler, 
	//Controller:= Controller,
	Enable:= GVL.PowerOn, 
	Reset:= GVL.ResetRtrig.Q, 
	StoredPositions:= PersistentVars.StoredPositions,
	VisionRegisters:= PersistentVars.VisionRegisters,
	Flags:= PersistentVars.Flags,
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );

IF GVL.StartHome THEN
	GVL.StartHome:=FALSE;
	GVL.PowerOn :=TRUE;
	ProcessHome.M_StartHoming();
END_IF
IF SetHome THEN
	SetHome:=FALSE;
	ProcessHome.M_SetHome();
END_IF
IF ProcessHome.Reset THEN
	HomingStatusText := '';
END_IF
IF ProcessHome.Error THEN
	(*HomingStatusText := CONCAT('Homing Processor Error: ',
						CONCAT(TO_STRING(ProcessHome.ErrorID),
						CONCAT(' ', SMC_ErrorString(ProcessHome.ErrorID,
									SMC_Language_Type.english)))) ;*)
	HomingStatusText := CONCAT('Homing Processor Error: ', TO_STRING(ProcessHome.ErrorID));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_Jogging" Id="{0244d8b9-9bfb-4b7e-b2e7-dffe5ddef546}">
      <Declaration><![CDATA[METHOD PRIVATE _M_Jogging : BOOL
VAR_STAT
	EnableRtrig: R_TRIG;
	CoordSystemLast: DUT_CoordSystem;
	ABC_AS_ACSLast: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// dont get sleepy
ProcessJog(
	GroupHandler:= GroupHandler, 
	ACS:= ACS, 
	MCS:= MCS, 
	//Controller:= Controller,
	Enable:= ,//GVL.PowerOn,
	Reset:= GVL.ResetRtrig.Q,
	StoredPositions:= PersistentVars.StoredPositions,
	VisionRegisters:= PersistentVars.VisionRegisters,
	Flags:= PersistentVars.Flags,
	ABC_as_ACS=>,
	CoordSystem=>, 
	Enabled=>,
	Position=>, 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorID=> );
	
// change the button texts on enable or a change of the coordinate system
EnableRtrig(CLK:=ProcessJog.CoordSystem <> CoordSystemLast
				OR ProcessJog.ABC_as_ACS <> ABC_AS_ACSLast);
IF EnableRtrig.Q THEN
	CoordSystemLast := ProcessJog.CoordSystem;
	ABC_AS_ACSLast := ProcessJog.ABC_as_ACS;
	//ButtonTextIndex := F_SetJogButtons(ProcessJog.CoordSystem, ProcessJog.ABC_as_ACS);
END_IF
	
//
IF ProcessJog.Reset THEN
	JogStatusText := '';
END_IF
IF ProcessJog.Error THEN
	(*JogStatusText := CONCAT('Jog Processor Error: ',
						CONCAT(TO_STRING(ProcessJog.ErrorID),
						CONCAT(' ', SMC_ErrorString(ProcessJog.ErrorID,
									SMC_Language_Type.english)))) ;*)
	JogStatusText := CONCAT('Jog Processor Error: ', TO_STRING(ProcessJog.ErrorID));
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_Processor" Id="{d0cb92ac-a65b-4a94-99d2-d1aa2daea05c}">
      <Declaration><![CDATA[METHOD PRIVATE _M_Processor : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF GVL.ResetRtrig.Q THEN
	ProcessPrograms.M_Home();
END_IF

ProcessPrograms(
	Programs:=PersistentVars.Programs,
	StoredPositions:=PersistentVars.StoredPositions,
	VisionRegisters:=PersistentVars.VisionRegisters,
	Flags:=PersistentVars.Flags,
	AxisGroup:= stGroupRef,
	GroupHandler:= GroupHandler,
	CmdIO:=GVL.CmdIO,
	Enable:= GVL.PowerOn AND PersistentVars.Flags[GVL.HOME_COMPLETE].Value,
	Error=> ,
	StatusText=>);

// for displaying on the HMI
// PGM: <number> CMD: <number> Type: <type> Command: <command> Comment: <comment>
ActiveCommandDetails := CONCAT('PGM: ', UINT_TO_STRING(ProcessPrograms.P_CurrentProgram));
ActiveCommandDetails := CONCAT(ActiveCommandDetails, ' CMD: ');
ActiveCommandDetails := CONCAT(ActiveCommandDetails, UINT_TO_STRING(ProcessPrograms.P_CurrentCommandIndex));
ActiveCommandDetails := CONCAT(ActiveCommandDetails, ' ');
ActiveCommandDetails := CONCAT(ActiveCommandDetails, TO_STRING(ProcessPrograms.P_CurrentCommand.CommandType));
ActiveCommandDetails := CONCAT(ActiveCommandDetails, ': ');
ActiveCommandDetails := CONCAT(ActiveCommandDetails, ProcessPrograms.P_CurrentCommand.CommandString);
ActiveCommandDetails := CONCAT(ActiveCommandDetails, ' Comment: ');
ActiveCommandDetails := CONCAT(ActiveCommandDetails, ProcessPrograms.P_CurrentCommand.CommandComment);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_SpookyHalloween" Id="{a639a100-d3c3-420a-82a3-fbee25b24829}">
      <Declaration><![CDATA[METHOD _M_SpookyHalloween
VAR_INPUT
END_VAR
VAR_STAT
	SeqReset: INT;
	ResetSeq: BOOL;
	SeqSpookyHalloween: INT;
	CurrentRow: INT:=0;
	CurrentColumn: INT:=0;
	PreparePick, PickGlowStick: BOOL;
	PickGlowStickRtrig: R_TRIG;
	AddPrePickPaths, AddPickPaths, AddPrePlacePaths, AddPlacePaths, movePrepError: BOOL;
	
	//
    fbMovePath: MC_MovePath;
	fbBlockerPreparation: MC_BlockerPreparation;
	fbReleaseBlocker: MC_ReleaseBlocker;
	fbGroupReadBlockerStatus: MC_GroupReadBlockerStatus;
	
	//
	path: MC_PATH_DATA_REF(ADR(buffer), SIZEOF(buffer));
    fbMoveLinPrep: MC_MoveLinearAbsolutePreparation;
    fbMoveCirPrep: MC_MoveCircularAbsolutePreparation;
	fbSetCoordTransPrep: MC_SetCoordinateTransformPreparation;
    aTargetPos: ARRAY[1..NumberOfAxes] OF MC_LREAL;
    aAuxPointPos: ARRAY[1..NumberOfAxes] OF MC_LREAL;
    aEndPointPos: ARRAY[1..NumberOfAxes] OF MC_LREAL;
    aTransitionParam: ARRAY[1..2] OF MC_LREAL;
	InvokeId: UDINT;
	
	//
	MoveAcs, AcsMoveDone: BOOL;
	mcMoveAbsoluteAcs: ARRAY[1..NumberOfAxes] OF MC_MoveAbsolute;
	MovePositionAcs: ARRAY[1..NumberOfAxes] OF LREAL:=[0, -15, 130, 0, -30, 0];
	
	//
	ResetGroup, EnableAcs, EnableMcs, EnableUcs1, EnableTcp, DisableGroup, 
	ToggleGripper, ToggleLaser, ToggleSmoke: BOOL;
	
	_x, _y, _z, _a, _b, _c: MC_LREAL;
	
	GrossVelocity: LREAL:=100.0; // mm/s
	FineVelocity: LREAL:=60.0; // mm/s
	
	// rotation is din9000 standard evaluated in the order z, then y, then x
	// this is how we want the end effector to be rotated in relation to the nest
	NestRotation_A: LREAL:=89.3; // degrees rotated about the x axis
	NestRotation_B: LREAL:=91.0; // degrees rotated about the y axis
	NestRotation_C: LREAL:=0.0; // degrees rotated about the z axis
	HandoffRotation_A: LREAL:=0.0; // degrees rotated about the x axis
	HandofRotation_B: LREAL:=90.0; // degrees rotated about the y axis
	HandofRotation_C: LREAL:=0.0; // degrees rotated about the z axis
	
	//
	SmokeTime: TIME:=T#2000MS;
	SmokeTimer: TON;
	LaserTime: TIME:=T#30S;
	LaserTimer: TON;
	BeeperPulseTime: TIME:=T#250MS;
	BeeperDwellTime: TIME:=T#750S;
	BeeperPulseHighTimer, BeeperPulseLowTimer: TON;
	BeeperDwellTimer: TON;
	BeeperTotalPulseCount: WORD:=2;
    BeeperTotalPulseGroups: WORD:=3;
	BeeperCurrentPulseCount, BeeperCurrentPulseGroupsCount: CTU;
    EnableBeeperRtrig: R_TRIG;
    EnableBeeperFtrig: F_TRIG;
	EnableBeeper: BOOL;
	BeeperSequence: INT;
	
END_VAR
VAR_STAT CONSTANT
	// Steps
	S_IDLE: INT:=0000;
	S_ENABLEGROUPACS1: INT:=0010;
	S_WAITENABLEGROUPACS1: INT:=0020;
	S_MOVEHOMEACS: INT:=0030;
	S_WAITMOVEHOMEACS: INT:=0040;
	S_DISABLEGROUPACS: INT:=0045;
	S_WAITFORDISABLEACS: INT:=0046;
	S_ENABLEGROUPUCS1: INT:=0070;
	S_WAITENABLEGROUPUCS1: INT:=0080;
	S_ADDPREPICKPATH: INT:=0090;
	S_PREPICK: INT:=0100;
	S_WAITFORPREPICKDONE: INT:=0110;
	S_WAITFORPICKTRIGGER: INT:=0130;
	S_ENABLEGROUPTCP1: INT:=0160;
	S_WAITENABLETCP1: INT:=0170;
	S_ADDPICKPATH: INT:=0180;
	S_PICK: INT:=0190;
	S_GRIP: INT:=0200;
	S_WAITFORPICKDONE: INT:=0210;
	S_ENABLEGROUPUCS2: INT:=0230;
	S_WAITENABLEGROUPUCS2: INT:=0240;
	S_ADDPREPLACEPATHS: INT:=0250;
	S_PREPLACE: INT:=0260;
	S_WAITFORPREPLACEDONE: INT:=0270;
	S_ENABLEGROUPTCP2: INT:=0310;
	S_WAITENABLEGROUPTCP2: INT:=0320;
	S_ADDPLACEPATHS: INT:=0330;
	S_PLACE: INT:=0340;
	S_UNGRIP: INT:=0350;
	S_WAITFROPLACEDONE: INT:=0360;

	//
	GRIPBLOCKERID: UDINT:=100;
	UNGRIPBLOCKERID: UDINT:=200;
	
	// Nest Dimensions
	TOTALROWS: INT:=11;
	TOTALCOLUMNS: INT:=17;
	ROWOFFSET: LREAL:=15.0;
	COLOFFSET: LREAL:=19.5;
	
	// Product Dimensions
	PICKHEIGHT: LREAL:=170.0; // mm
	GRIPDEPTH: LREAL:=15.0; // mm
	UNGRIPDEPTH: LREAL:=50.0; // mm
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[{region 'testing'}
// use these to manage the group manually while testing.
// if things get out of wack, you can always reset, disable, then reset and all will be well again
IF ResetGroup THEN
	ResetGroup := FALSE;
	GroupHandler.M_ResetGroup();
END_IF
IF EnableAcs THEN
	EnableAcs := FALSE;
	GroupHandler.M_EnableGroup(DUT_CoordSystem.ACS);
END_IF
IF EnableMcs THEN
	EnableMcs := FALSE;
	GroupHandler.M_EnableGroup(DUT_CoordSystem.MCS);
END_IF
IF EnableUcs1 THEN
	EnableUcs1 := FALSE;
	GroupHandler.M_EnableGroup(DUT_CoordSystem.UCS1);
END_IF
IF EnableTcp THEN
	EnableTcp := FALSE;
	GroupHandler.M_EnableGroup(DUT_CoordSystem.TCP);
END_IF
IF DisableGroup THEN
	DisableGroup := FALSE;
	GroupHandler.M_DisableGroup();
END_IF
IF ToggleGripper THEN
	ToggleGripper := FALSE;
	Gripper.Toggle();
END_IF
IF ToggleLaser THEN
	ToggleLaser := FALSE;
	Laser.Toggle();
END_IF
IF ToggleSmoke THEN
	ToggleSmoke := FALSE;
	Smoke.Toggle();
END_IF

// handy variables
GroupVelocityFactor;
GVL.Reset; GVL.PowerOn; GVL.StartHome; ResetSeq;
CurrentRow; CurrentColumn;
PreparePick; PickGlowStick;
PersistentVars.StoredPositions[GVL.TCP_POS_IDX].Position;
PersistentVars.StoredPositions[GVL.UC1_POS_IDX].Position;
PersistentVars.StoredPositions[GVL.UC2_POS_IDX].Position;
PersistentVars.Flags[GVL.HOME_COMPLETE].Value;
	
{endregion}

PickGlowStickRtrig(CLK:=PickGlowStick);
IF PickGlowStickRtrig.Q THEN
	PickGlowStick := FALSE;
END_IF

CASE SeqReset OF
	0:
		IF ResetSeq THEN
			ResetSeq:=FALSE;
			SeqSpookyHalloween := 0;
			GroupHandler.M_DisableGroup();
            Gripper.On(); // open the gripper
            EnableBeeper := FALSE;
            Beacon.Off();
            Smoke.Off();
            Laser.Off();
            //UVLight.Off();
			SeqReset := SeqReset + 1;
		END_IF
	1:
		IF NOT GroupHandler.P_GroupReady THEN
			GroupHandler.M_ResetGroup();
			SeqReset := 0;
		END_IF
END_CASE

//
CASE SeqSpookyHalloween OF
	S_IDLE: //
		IF PreparePick THEN
			PreparePick := FALSE;
			//
			GVL.PowerOn := TRUE; // TODO this should arguably not be here but leaving it here for dev and testing
			AddPrePickPaths := AddPickPaths := AddPrePlacePaths := AddPlacePaths :=FALSE;
			PickGlowStick := FALSE;
			fbMovePath.Execute := fbReleaseBlocker.Execute :=FALSE;
			movePrepError := FALSE;
			Gripper.On(); // open the gripper
			//
			MoveAcs:=FALSE;
			//
			SeqSpookyHalloween := S_ENABLEGROUPACS1;
		END_IF
		
	S_ENABLEGROUPACS1: // enable group in the ACS (axis coordinate system)
		IF GroupHandler.M_EnableGroup(DUT_CoordSystem.ACS) THEN
 			SeqSpookyHalloween := S_WAITENABLEGROUPACS1;
		END_IF
		
	S_WAITENABLEGROUPACS1: // wait for group to be ready
		IF GroupHandler.P_GroupReady THEN
 			SeqSpookyHalloween := S_MOVEHOMEACS;
		END_IF
		
	S_MOVEHOMEACS: // execute absolute moves for all axes
		MoveAcs:=TRUE;
		SeqSpookyHalloween := S_WAITMOVEHOMEACS;
	
	S_WAITMOVEHOMEACS: // wait for all absolute moves to be done
		AcsMoveDone:=TRUE;
		FOR _i:=1 TO NumberOfAxes BY 1 DO
			IF NOT mcMoveAbsoluteAcs[_i].Done THEN
				AcsMoveDone:=FALSE;
			END_IF
		END_FOR
		IF AcsMoveDone THEN
			MoveAcs:=FALSE;
			SeqSpookyHalloween := S_DISABLEGROUPACS;
		END_IF
		
	S_DISABLEGROUPACS: // disable the group so that we can reenable in a cartesian coordinate system
		IF GroupHandler.M_DisableGroup() THEN
			SeqSpookyHalloween := S_WAITFORDISABLEACS;
		END_IF
		
	S_WAITFORDISABLEACS: // wait for the ACS to be disabled and move to the next step
		IF NOT GroupHandler.P_GroupReady THEN
			SeqSpookyHalloween := S_WAITFORPICKTRIGGER;
		ELSE
			//
		END_IF
		
	S_WAITFORPICKTRIGGER: // stay here until triggered to pick a glowstick
		IF PickGlowStickRtrig.Q THEN
            // give an audiable and visual warning that movement is about to happen
            EnableBeeper := TRUE;
            Beacon.On();
			SeqSpookyHalloween := S_WAITFORMOVEMENTWARNING;
		END_IF
        
    S_WAITFORMOVEMENTWARNING:
        IF NOT EnableBeeper THEN
            Beacon.Off();
			Smoke.On();
            Laser.On();
			SeqSpookyHalloween := S_ENABLEGROUPUCS1;
        END_IF
		
	S_ENABLEGROUPUCS1: // enable the group in a cartesian coordinate system
		IF GroupHandler.M_EnableGroup(DUT_CoordSystem.UCS1) THEN
			SeqSpookyHalloween := S_WAITENABLEGROUPUCS1;
		ELSE
			//
		END_IF
		
	S_WAITENABLEGROUPUCS1: // wait for the group to be ready
		IF GroupHandler.P_GroupReady THEN
 			SeqSpookyHalloween := S_ADDPREPICKPATH;
		END_IF
		
	S_ADDPREPICKPATH: // add pre-pick paths to the motion queue
		AddPrePickPaths:=TRUE;
		movePrepError:=FALSE;
		fbMovePath.Execute:=FALSE;
		SeqSpookyHalloween := S_PREPICK;
	
	S_PREPICK: // after paths have been added, execute movement
		IF NOT movePrepError AND NOT AddPrePickPaths THEN
			fbMovePath.Execute := TRUE;
			SeqSpookyHalloween := S_WAITFORPREPICKDONE;
		ELSE
			//
		END_IF
		
	S_WAITFORPREPICKDONE: // wait for the pre-pick moves to be complete
		IF fbMovePath.Error THEN
			//
		ELSIF fbMovePath.Done THEN
			fbMovePath.Execute := FALSE;
			SeqSpookyHalloween := S_ENABLEGROUPTCP1;
		END_IF
	
	S_ENABLEGROUPTCP1: // change the coordinate system to the TCP
		IF GroupHandler.M_SetTransform(DUT_CoordSystem.TCP) THEN
			SeqSpookyHalloween := S_WAITENABLETCP1;
		ELSE
			//
		END_IF
	
	S_WAITENABLETCP1: // wait for the transform to be set
		IF GroupHandler.P_TransformSet THEN
			SeqSpookyHalloween := S_ADDPICKPATH;
		END_IF
	
	S_ADDPICKPATH: // add all pick paths to the motion queue
		AddPickPaths:=TRUE;
		movePrepError:=FALSE;
		fbMovePath.Execute:=FALSE;
		fbReleaseBlocker.Execute:=FALSE;
		SeqSpookyHalloween := S_PICK;
	
	S_PICK: // after all paths have been added, execute motion
		IF NOT movePrepError AND NOT AddPickPaths THEN
            //UVLight.On();
			fbMovePath.Execute := TRUE;
			// wait for gripper to be open and tool in position
			IF fbGroupReadBlockerStatus.Blocked AND fbGroupReadBlockerStatus.BlockerId = GRIPBLOCKERID THEN
				SeqSpookyHalloween := S_GRIP;
			END_IF
		ELSE
			//
		END_IF
		
	S_GRIP: // close the gripper and release the blocker
		Gripper.Off(); // TODO may need to wait for a time here or add inputs to the gripper
		fbReleaseBlocker.BlockerId:=GRIPBLOCKERID;
		fbReleaseBlocker.Execute:=TRUE;
		SeqSpookyHalloween := S_WAITFORPICKDONE;
		
	S_WAITFORPICKDONE: // after the gripper has been unblocked, wait for the remaining motion to complete
		IF fbMovePath.Error THEN
			//
		ELSIF fbMovePath.Done THEN
            //UVLight.Off();
			fbMovePath.Execute := FALSE;
            // increment the column and row so that we pick the next glow stick on the next try.
			// roll back over to start once we reach the last glow stick.
            IF CurrentColumn < TOTALCOLUMNS-1 THEN
                CurrentColumn := CurrentColumn + 1;
            ELSE
                CurrentColumn := 0;
                IF CurrentRow < TOTALROWS-1 THEN
                    CurrentRow := CurrentRow + 1;
                ELSE
                    CurrentRow := 0;
                END_IF
            END_IF
			SeqSpookyHalloween := S_ENABLEGROUPUCS2;
		END_IF
	
	S_ENABLEGROUPUCS2: // change the coordinate system to the UCS1 (user coordinate system 1)
		IF GroupHandler.M_SetTransform(DUT_CoordSystem.UCS1) THEN
			SeqSpookyHalloween := S_WAITENABLEGROUPUCS2;
		ELSE
			//
		END_IF
	
	S_WAITENABLEGROUPUCS2: // wait for the transformation to be complete
		IF GroupHandler.P_TransformSet THEN
			SeqSpookyHalloween := S_ADDPREPLACEPATHS;
		END_IF
	
	S_ADDPREPLACEPATHS: // add the pre-place paths to the motion queue
		AddPrePlacePaths:=TRUE;
		movePrepError:=FALSE;
		fbMovePath.Execute:=FALSE;
		SeqSpookyHalloween := S_PREPLACE;
	
	S_PREPLACE: // after all motion paths have been added to the queue, move to the pre-place position
		IF NOT movePrepError AND NOT AddPrePlacePaths THEN
			fbMovePath.Execute := TRUE;
			SeqSpookyHalloween := S_WAITFORPREPLACEDONE;
		ELSE
			//
		END_IF
		
	S_WAITFORPREPLACEDONE: // wait for motion to be complete and tool to be in pre-place position
		IF fbMovePath.Error THEN
			//
		ELSIF fbMovePath.Done THEN
			fbMovePath.Execute := FALSE;
			SeqSpookyHalloween := S_ENABLEGROUPTCP2;
		END_IF
	
	S_ENABLEGROUPTCP2: // change the coordinate system back to the TCP
		IF GroupHandler.M_SetTransform(DUT_CoordSystem.TCP) THEN
			SeqSpookyHalloween := S_WAITENABLEGROUPTCP2;
		ELSE
			//
		END_IF
	
	S_WAITENABLEGROUPTCP2: // wait for the transformation to be complete
		IF GroupHandler.P_TransformSet THEN
			SeqSpookyHalloween := S_ADDPLACEPATHS;
		END_IF
	
	S_ADDPLACEPATHS: // add all place paths to the motion queue
		AddPlacePaths:=TRUE;
		movePrepError:=FALSE;
		fbMovePath.Execute:=FALSE;
		fbReleaseBlocker.Execute:=FALSE;
		SeqSpookyHalloween := S_PLACE;
	
	S_PLACE: // once all place paths have been added, execute motiong and place the glowstick
		IF NOT movePrepError AND NOT AddPlacePaths THEN
			fbMovePath.Execute := TRUE;
			// wait for gripper to be open and tool in position
			IF fbGroupReadBlockerStatus.Blocked AND fbGroupReadBlockerStatus.BlockerId = UNGRIPBLOCKERID THEN
				SeqSpookyHalloween := S_UNGRIP;
			END_IF
		ELSE
			//
		END_IF
		
	S_UNGRIP: // open the gripper and release the blocker
		Gripper.On(); // TODO may need to wait for a time here or add inputs to the gripper
		fbReleaseBlocker.BlockerId:=UNGRIPBLOCKERID;
		fbReleaseBlocker.Execute:=TRUE;
		SeqSpookyHalloween := S_WAITFROPLACEDONE;
	
	S_WAITFROPLACEDONE: // wait for the motion to be complete and go back to wait for trigger
		IF fbMovePath.Error THEN
			//
		ELSIF fbMovePath.Done THEN
			Laser.Off();
			fbMovePath.Execute := FALSE;
			SeqSpookyHalloween := S_DISABLEGROUPACS;
		END_IF
	
END_CASE

{region 'function blocks'}
//
fbMovePath(
	AxesGroup:= stGroupRef, 
	PathData:= path, 
	Execute:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorId=> );
fbGroupReadBlockerStatus(
	AxesGroup:= stGroupRef, 
	Enable:= TRUE, 
	Valid=> , 
	Blocked=> , 
	BlockerId=> );
fbReleaseBlocker(
	AxesGroup:= stGroupRef, 
	Execute:= , 
	BlockerId:= , 
	Done=> , 
	Busy=> , 
	Error=> , 
	ErrorId=> );
FOR _k:= 1 TO NumberOfAxes DO
	mcMoveAbsoluteAcs[_k](
		Axis:= ACS[_k], 
		Execute:= MoveAcs, 
		Position:= MovePositionAcs[_k], 
		Velocity:= 10, 
		Acceleration:= 1000, 
		Deceleration:= 1000, 
		Jerk:= 100, 
		BufferMode:= , 
		Options:= , 
		Done=> , 
		Busy=> , 
		Active=> , 
		CommandAborted=> , 
		Error=> , 
		ErrorID=> );
END_FOR

//
SmokeTimer(IN:=Smoke.P_StateOn, PT:=SmokeTime);
IF SmokeTimer.Q THEN
    Smoke.Off();
END_IF
//
LaserTimer(IN:=Laser.P_StateOn, PT:=LaserTime);
IF LaserTimer.Q THEN
    Laser.Off();
END_IF
//
    EnableBeeperRtrig(CLK:=EnableBeeper);
    EnableBeeperFtrig(CLK:=EnableBeeper);
    IF EnableBeeperFtrig.Q THEN
        BeeperSequence := -1;
    END_IF
	CASE BeeperSequence OF
        -1: // reset state
            Beeper.Off();
            BeeperCurrentPulseCount(RESET:=TRUE, CU:=FALSE);
            BeeperCurrentPulseGroupsCount(RESET:=TRUE, CU:=FALSE);
            BeeperPulseHighTimer(IN:=FALSE);
            BeeperPulseLowTimer(IN:=FALSE);
            BeeperDwellTimer(IN:=FALSE);
			BeeperSequence := BeeperSequence + 1;
		0: // wait for trigger
			IF EnableBeeperRtrig.Q THEN
				BeeperSequence := BeeperSequence + 1;
			END_IF
		1: // pulse high
            Beeper.On();
            BeeperCurrentPulseCount(PV:=BeeperTotalPulseCount, CU:=TRUE, RESET:=FALSE);
            BeeperPulseHighTimer(IN:=TRUE, PT:=BeeperPulseTime);
			IF BeeperPulseHighTimer.Q THEN
                BeeperPulseHighTimer(IN:=FALSE);
                BeeperCurrentPulseCount(CU:=FALSE);
				BeeperSequence := BeeperSequence + 1;
			END_IF
        2: // pulse low
            Beeper.Off();
            BeeperPulseLowTimer(IN:=TRUE, PT:=BeeperPulseTime);
            IF BeeperCurrentPulseCount.Q THEN // check the counter first so we dont all a tail on the last pulse
                BeeperCurrentPulseCount(RESET:=TRUE, CU:=FALSE);
                BeeperPulseLowTimer(IN:=FALSE);
                BeeperSequence := BeeperSequence + 1;
            ELSIF BeeperPulseLowTimer.Q THEN
                BeeperPulseLowTimer(IN:=FALSE);
                BeeperSequence := BeeperSequence - 1;
            END_IF
		3: // dwell
            BeeperCurrentPulseGroupsCount(PV:=BeeperTotalPulseGroups, CU:=TRUE, RESET:=FALSE);
            BeeperDwellTimer(IN:=TRUE, PT:=BeeperDwellTime);
            IF BeeperCurrentPulseGroupsCount.Q THEN // check the counter first so we do wait the dwell time after the last set of pulses
                EnableBeeper := FALSE;
                BeeperSequence := -1;
            ELSIF BeeperDwellTimer.Q THEN
                BeeperCurrentPulseGroupsCount(CU:=FALSE);
                BeeperDwellTimer(IN:=FALSE);
                BeeperSequence := BeeperSequence - 2;
            END_IF
	END_CASE
	
{endregion}
	
{region 'add ucs1 paths'}
//
IF AddPrePickPaths THEN
	AddPrePickPaths := FALSE;
	
	path.ClearPath();  //Clear nodes that were in path
	IF path.OccupiedBuffer <> 0 THEN
		MovePrepError := TRUE;
	ELSE
		InvokeId := 0;
	
		fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
		fbMoveLinPrep.PositionCount 				:= NumberOfAxes; //number of axes in group
		fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
		fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
		fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
		fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
		//Set dynamics to default values of the axes
		fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
		fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
		fbMoveLinPrep.Jerk							:= MC_DEFAULT;
		
		// no need to do this here since we are using the group handler function block.
		// leaving here for example documentation.
		// set ucs frame
		//fbSetCoordTransPrep(PathData:=path, CoordTransform:=GVL.Ucs1CoordRef);
		//MovePrepError := MovePrepError OR fbSetCoordTransPrep.Error;
		
		// 1st node
		aTargetPos[1]				:= 0.0; // x
		aTargetPos[2]				:= 0.0; // y
		aTargetPos[3]				:= 0.0; // z
		aTargetPos[4]				:= NestRotation_A; // a 
		aTargetPos[5]				:= NestRotation_B; // b
		aTargetPos[6]				:= NestRotation_C; // c
		aTransitionParam[1]			:= 0; // blending distance on previous segment
		aTransitionParam[2]			:= 0; // blending distance on previous segment
		InvokeId 					:= InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
		fbMoveLinPrep(PathData:= path , Velocity:= GrossVelocity, InvokeId:= InvokeId);
		MovePrepError := MovePrepError OR fbMoveLinPrep.Error;
	END_IF
	
END_IF
IF AddPrePlacePaths THEN
	AddPrePlacePaths := FALSE;
	
	path.ClearPath();  //Clear nodes that were in path
	IF path.OccupiedBuffer <> 0 THEN
		MovePrepError := TRUE;
	ELSE
		InvokeId := 0;
	
		fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
		fbMoveLinPrep.PositionCount 				:= NumberOfAxes; //number of axes in group
		fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
		fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
		fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
		fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
		//Set dynamics to default values of the axes
		fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
		fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
		fbMoveLinPrep.Jerk							:= MC_DEFAULT;
		
		// no need to do this here since we are using the group handler function block.
		// leaving here for example documentation.
		// set ucs frame
		//fbSetCoordTransPrep(PathData:=path, CoordTransform:=GVL.Ucs1CoordRef);
		//MovePrepError := MovePrepError OR fbSetCoordTransPrep.Error;
		
		// 1st node
		aTargetPos[1]				:= 50; // x
		aTargetPos[2]				:= 200; // y
		aTargetPos[3]				:= 180; // z
		aTargetPos[4]				:= HandoffRotation_A; // a
		aTargetPos[5]				:= HandofRotation_B; // b
		aTargetPos[6]				:= HandofRotation_C; // c
		aTransitionParam[1]			:= 0; // blending distance on previous segment
		aTransitionParam[2]			:= 0; // blending distance on previous segment
		InvokeId 					:= InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
		fbMoveLinPrep(PathData:= path , Velocity:= GrossVelocity, InvokeId:= InvokeId);
		MovePrepError := MovePrepError OR fbMoveLinPrep.Error;
	END_IF
	
END_IF
{endregion}
{region 'add tcp paths'}
//
IF AddPickPaths THEN
	AddPickPaths := FALSE;
	
	path.ClearPath();  //Clear nodes that were in path
	IF path.OccupiedBuffer <> 0 THEN
		MovePrepError := TRUE;
	ELSE
		InvokeId := 0;
	
		fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
		fbMoveLinPrep.PositionCount 				:= NumberOfAxes; //number of axes in group
		fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
		fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
		fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
		fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
		//Set dynamics to default values of the axes
		fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
		fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
		fbMoveLinPrep.Jerk							:= MC_DEFAULT;
		
		// no need to do this here since we are using the group handler function block.
		// leaving here for example documentation.
		//fbSetCoordTransPrep(PathData:=path, CoordTransform:=GVL.TcpCoordRef);
		//MovePrepError := MovePrepError OR fbSetCoordTransPrep.Error;
		
		//1st node
		aTargetPos[1]				:= 0; // x
		aTargetPos[2]				:= -(CurrentColumn * COLOFFSET); // y
		aTargetPos[3]				:= (CurrentRow * ROWOFFSET); // z
		aTargetPos[4]				:= mcs[4].NcToPlc.ActPos + 0.0; // a
		aTargetPos[5]				:= mcs[5].NcToPlc.ActPos + 0.0; // b
		aTargetPos[6]				:= mcs[6].NcToPlc.ActPos + 0.0; // c
		aTransitionParam[1]			:= 0; // blending distance on previous segmente
		aTransitionParam[2]			:= 0; // blending distance on previous segment
		InvokeId 					:= InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
		fbMoveLinPrep(PathData:= path , Velocity:= FineVelocity, InvokeId:= InvokeId);
		MovePrepError := MovePrepError OR fbMoveLinPrep.Error;
		
		//1st node
		aTargetPos[1]				:= 0; // x
		aTargetPos[2]				:= -(CurrentColumn * COLOFFSET); // y
		aTargetPos[3]				:= (CurrentRow * ROWOFFSET) + GRIPDEPTH; // z
		aTargetPos[4]				:= mcs[4].NcToPlc.ActPos + 0.0; // a
		aTargetPos[5]				:= mcs[5].NcToPlc.ActPos + 0.0; // b
		aTargetPos[6]				:= mcs[6].NcToPlc.ActPos + 0.0; // c
		aTransitionParam[1]			:= 0; // blending distance on previous segmente
		aTransitionParam[2]			:= 0; // blending distance on previous segment
		InvokeId 					:= InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
		fbMoveLinPrep(PathData:= path , Velocity:= FineVelocity, InvokeId:= InvokeId);
		MovePrepError := MovePrepError OR fbMoveLinPrep.Error;
		
		// example of how to add a blocker to the path data
		InvokeId := InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
		fbBlockerPreparation(
			PathData:= path, 
			BlockerId:= GRIPBLOCKERID, // blocker id is unique
			BufferMode:= mcBuffered, 
			InvokeId:= InvokeId, 
			Error=> , 
			ErrorId=> );
		
		//1st node
		aTargetPos[1]				:= -PICKHEIGHT; // x
		aTargetPos[2]				:= -(CurrentColumn * COLOFFSET); // y
		aTargetPos[3]				:= (CurrentRow * ROWOFFSET) + GRIPDEPTH; // z
		aTargetPos[4]				:= mcs[4].NcToPlc.ActPos + 0.0; // a
		aTargetPos[5]				:= mcs[5].NcToPlc.ActPos + 0.0; // b
		aTargetPos[6]				:= mcs[6].NcToPlc.ActPos + 0.0; // c
		aTransitionParam[1]			:= 0; // blending distance on previous segment
		aTransitionParam[2]			:= 0; // blending distance on previous segment
		InvokeId 					:= InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
		fbMoveLinPrep(PathData:= path , Velocity:= FineVelocity, InvokeId:= InvokeId);
		MovePrepError := MovePrepError OR fbMoveLinPrep.Error;
	END_IF
	
END_IF
IF AddPlacePaths THEN
	AddPlacePaths := FALSE;
	
	path.ClearPath();  //Clear nodes that were in path
	IF path.OccupiedBuffer <> 0 THEN
		MovePrepError := TRUE;
	ELSE
		InvokeId := 0;
	
		fbMoveLinPrep.Position						:= ADR(aTargetPos); //pointer to position array
		fbMoveLinPrep.PositionCount 				:= NumberOfAxes; //number of axes in group
		fbMoveLinPrep.TransitionParameter			:= ADR (aTransitionParam); //pointer to transition parameter array
		fbMoveLinPrep.TransitionParameterCount		:= 2; //number of transition parameters, has to be set always 2
		fbMoveLinPrep.BufferMode					:= mcBlendingPrevious;
		fbMoveLinPrep.TransitionMode				:= mcTransModeCornerDistanceAdvanced;
		//Set dynamics to default values of the axes
		fbMoveLinPrep.Acceleration					:= MC_DEFAULT;
		fbMoveLinPrep.Deceleration					:= MC_DEFAULT;
		fbMoveLinPrep.Jerk							:= MC_DEFAULT;
		
		// no need to do this here since we are using the group handler function block.
		// leaving here for example documentation.
		//fbSetCoordTransPrep(PathData:=path, CoordTransform:=GVL.TcpCoordRef);
		//MovePrepError := MovePrepError OR fbSetCoordTransPrep.Error;
		
// 		// center of circle
// 		aAuxPointPos[1]				:= _x; // x
// 		aAuxPointPos[2]				:= _y; // y
// 		aAuxPointPos[3]				:= _z; // z
// 		aAuxPointPos[4]				:= mcs[4].NcToPlc.ActPos; // a
// 		aAuxPointPos[5]				:= mcs[5].NcToPlc.ActPos; // b
// 		aAuxPointPos[6]				:= mcs[6].NcToPlc.ActPos; // c
//         // end point on circle
// 		aEndPointPos[1]				:= _a; // x
// 		aEndPointPos[2]				:= _b; // y
// 		aEndPointPos[3]				:= _c; // z
// 		aEndPointPos[4]				:= mcs[4].NcToPlc.ActPos; // a
// 		aEndPointPos[5]				:= mcs[5].NcToPlc.ActPos; // b
// 		aEndPointPos[6]				:= mcs[6].NcToPlc.ActPos; // c
// 		aTransitionParam[1]			:= 0; // blending distance on previous segment
// 		aTransitionParam[2]			:= 0; // blending distance on previous segment
// 		InvokeId 					:= InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
//         fbMoveCirPrep(
//             PathData:= path, CircMode:= MC_CIRC_MODE.mcCircModeCenter, 
//             AuxPoint:= ADR(aAuxPointPos), AuxPointCount:= NumberOfAxes, 
//             EndPoint:= ADR(aEndPointPos), EndPointCount:= NumberOfAxes, 
//             PathChoice:= MC_CIRC_PATHCHOICE.mcCircPathChoiceClockwise, 
//             Velocity:=FineVelocity, Acceleration:=MC_DEFAULT, Deceleration:=MC_DEFAULT, Jerk:= MC_DEFAULT, 
//             BufferMode:=mcBuffered, TransitionMode:=mcTransModeNone, 
//             TransitionParameter:=ADR(aTransitionParam), TransitionParameterCount:=2, 
//             InvokeId:= InvokeId);
// 		MovePrepError := MovePrepError OR fbMoveCirPrep.Error;
		
		//1st node
		aTargetPos[1]				:= 0; // x
		aTargetPos[2]				:= 0; // y
		aTargetPos[3]				:= UNGRIPDEPTH; // z
		aTargetPos[4]				:= mcs[4].NcToPlc.ActPos; // HandoffRotation_A; // a
		aTargetPos[5]				:= mcs[5].NcToPlc.ActPos; // HandofRotation_B; // b
		aTargetPos[6]				:= mcs[6].NcToPlc.ActPos; // HandofRotation_C; // c
		aTransitionParam[1]			:= 0; // blending distance on previous segment
		aTransitionParam[2]			:= 0; // blending distance on previous segment
		InvokeId 					:= InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
		fbMoveLinPrep(PathData:= path , Velocity:= FineVelocity, InvokeId:= InvokeId);
		MovePrepError := MovePrepError OR fbMoveLinPrep.Error;
		
		// example of how to add a blocker to the path data
		InvokeId := InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
		fbBlockerPreparation(
			PathData:= path, 
			BlockerId:= UNGRIPBLOCKERID, // blocker id is unique
			BufferMode:= mcBuffered, 
			InvokeId:= InvokeId, 
			Error=> , 
			ErrorId=> );
		
		//1st node
		aTargetPos[1]				:= 0; // x
		aTargetPos[2]				:= 0; // y
		aTargetPos[3]				:= 0; // z
		aTargetPos[4]				:= mcs[4].NcToPlc.ActPos; // HandoffRotation_A; // a
		aTargetPos[5]				:= mcs[5].NcToPlc.ActPos; // HandofRotation_B; // b
		aTargetPos[6]				:= mcs[6].NcToPlc.ActPos; // HandofRotation_C; // c
		aTransitionParam[1]			:= 0; // blending distance on previous segment
		aTransitionParam[2]			:= 0; // blending distance on previous segment
		InvokeId 					:= InvokeId + 10; // this is just used for debugging in the case a cnc command goes wrong
		fbMoveLinPrep(PathData:= path , Velocity:= FineVelocity, InvokeId:= InvokeId);
		MovePrepError := MovePrepError OR fbMoveLinPrep.Error;
	END_IF
	
END_IF
{endregion}]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_Tuning" Id="{7bc5b496-9c33-4d9b-b0d8-4ee9652747d2}">
      <Declaration><![CDATA[METHOD PRIVATE _M_Tuning : BOOL
VAR_INPUT
END_VAR
VAR_STAT
	_MoveDelayTimer: ARRAY[0..5] OF TON;
	_TraceStartFtrig: ARRAY[0..5] OF F_TRIG;
	_MoveBusyFtrig: ARRAY[0..5] OF F_TRIG;
	_MoveDelayTime: INT:=10; // ms
	_i, _j, _k: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
// initial values
IF SetTuningMoveValues AND_THEN PersistentVars.Flags[GVL.INIT_DRV_IDX].Value THEN
	SetTuningMoveValues := FALSE;
	
	MoveRelative[0].Velocity := SM_Drive_PosControl_J1.fSWMaxVelocity;
	MoveRelative[0].Acceleration := SM_Drive_PosControl_J1.fSWMaxAcceleration;
	MoveRelative[0].Deceleration := SM_Drive_PosControl_J1.fSWMaxDeceleration;
	MoveRelative[0].Jerk := SM_Drive_PosControl_J1.fSWMaxJerk;
	MoveRelative[0].Distance := MoveDistance;
	
	MoveRelative[1].Velocity := SM_Drive_PosControl_J2.fSWMaxVelocity;
	MoveRelative[1].Acceleration := SM_Drive_PosControl_J2.fSWMaxAcceleration;
	MoveRelative[1].Deceleration := SM_Drive_PosControl_J2.fSWMaxDeceleration;
	MoveRelative[1].Jerk := SM_Drive_PosControl_J2.fSWMaxJerk;
	MoveRelative[1].Distance := MoveDistance;
	
	MoveRelative[2].Velocity := SM_Drive_PosControl_J3.fSWMaxVelocity;
	MoveRelative[2].Acceleration := SM_Drive_PosControl_J3.fSWMaxAcceleration;
	MoveRelative[2].Deceleration := SM_Drive_PosControl_J3.fSWMaxDeceleration;
	MoveRelative[2].Jerk := SM_Drive_PosControl_J3.fSWMaxJerk;
	MoveRelative[2].Distance := MoveDistance;
	
	MoveRelative[3].Velocity := SM_Drive_PosControl_J4.fSWMaxVelocity;
	MoveRelative[3].Acceleration := SM_Drive_PosControl_J4.fSWMaxAcceleration;
	MoveRelative[3].Deceleration := SM_Drive_PosControl_J4.fSWMaxDeceleration;
	MoveRelative[3].Jerk := SM_Drive_PosControl_J4.fSWMaxJerk;
	MoveRelative[3].Distance := MoveDistance;
	
	MoveRelative[4].Velocity := SM_Drive_PosControl_J5.fSWMaxVelocity;
	MoveRelative[4].Acceleration := SM_Drive_PosControl_J5.fSWMaxAcceleration;
	MoveRelative[4].Deceleration := SM_Drive_PosControl_J5.fSWMaxDeceleration;
	MoveRelative[4].Jerk := SM_Drive_PosControl_J5.fSWMaxJerk;
	MoveRelative[4].Distance := MoveDistance;
	
	MoveRelative[5].Velocity := SM_Drive_PosControl_J6.fSWMaxVelocity;
	MoveRelative[5].Acceleration := SM_Drive_PosControl_J6.fSWMaxAcceleration;
	MoveRelative[5].Deceleration := SM_Drive_PosControl_J6.fSWMaxDeceleration;
	MoveRelative[5].Jerk := SM_Drive_PosControl_J6.fSWMaxJerk;
	MoveRelative[5].Distance := MoveDistance;
END_IF

// trace activation
FOR _i:=0 TO 5 BY 1 DO
	
	//
	IF TuneStart[_i] THEN
		TuneStart[_i] := FALSE;
		TraceStart[_i] := TRUE; // trace will handshake this bit low
		GroupHandler.M_EnableGroup();
	END_IF
	
	// TraceStart will clear after handshake. this means the trace has started collecting samples
	// start the move delay timer to capture samples before the move
	_TraceStartFtrig[_i](CLK:=TraceStart[_i]);
	IF _TraceStartFtrig[_i].Q THEN
		_MoveDelayTimer[_i].IN:=TRUE;
	END_IF
	
	// once the move delay expires, start the move
	_MoveDelayTimer[_i](PT:=INT_TO_TIME(_MoveDelayTime));
	IF _MoveDelayTimer[_i].Q THEN
		_MoveDelayTimer[_i].IN:=FALSE;
		MoveRelative[_i].Execute := TRUE;
	END_IF
	
	//
	_MoveBusyFtrig[_i](CLK:=MoveRelative[_i].Busy);
	IF _MoveBusyFtrig[_i].Q THEN
		MoveRelative[_i].Execute := FALSE;
		MoveRelative[_i].Distance := MoveRelative[_i].Distance * -1.0; // reverse direction
	END_IF

END_FOR


// move relative
MoveRelative[0](
	Axis:= SM_Drive_PosControl_J1, 
	Execute:= , 
	Distance:= , 
	Velocity:= , 
	Acceleration:= , 
	Deceleration:= , 
	Jerk:= , 
	BufferMode:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
MoveRelative[1](
	Axis:= SM_Drive_PosControl_J2, 
	Execute:= , 
	Distance:= , 
	Velocity:= , 
	Acceleration:= , 
	Deceleration:= , 
	Jerk:= , 
	BufferMode:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
MoveRelative[2](
	Axis:= SM_Drive_PosControl_J3, 
	Execute:= , 
	Distance:= , 
	Velocity:= , 
	Acceleration:= , 
	Deceleration:= , 
	Jerk:= , 
	BufferMode:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
MoveRelative[3](
	Axis:= SM_Drive_PosControl_J4, 
	Execute:= , 
	Distance:= , 
	Velocity:= , 
	Acceleration:= , 
	Deceleration:= , 
	Jerk:= , 
	BufferMode:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
MoveRelative[4](
	Axis:= SM_Drive_PosControl_J5, 
	Execute:= , 
	Distance:= , 
	Velocity:= , 
	Acceleration:= , 
	Deceleration:= , 
	Jerk:= , 
	BufferMode:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
MoveRelative[5](
	Axis:= SM_Drive_PosControl_J6, 
	Execute:= , 
	Distance:= , 
	Velocity:= , 
	Acceleration:= , 
	Deceleration:= , 
	Jerk:= , 
	BufferMode:= , 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
    *)]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_BuildTests" Id="{9a5607a2-ed23-4572-beb3-b80fd95846d5}">
      <Declaration><![CDATA[METHOD PUBLIC M_BuildTests
VAR_INPUT
END_VAR
VAR
	_i, _j, _k: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[1].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[1].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[1].ProgramName := 'Vision Pick and Place';
PersistentVars.Programs[1].Commands[0].CommandType := DUT_CommandType.VarSetCommand;
PersistentVars.Programs[1].Commands[0].CommandString := 'STO 0046 +0000.00 +0000.00 +0000.00 +0090.00 +0000.00 +0000.00';
PersistentVars.Programs[1].Commands[1].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[1].Commands[1].CommandString := 'DIR ABS 020 ACS LIT 00000.00 00030.00 -0030.00 00000.00 00030.00 00000.00';
PersistentVars.Programs[1].Commands[2].CommandType := DUT_CommandType.OutputCommand;
PersistentVars.Programs[1].Commands[2].CommandString := 'DIG 1 1';
PersistentVars.Programs[1].Commands[3].CommandType := DUT_CommandType.VisionCommand;
PersistentVars.Programs[1].Commands[3].CommandString := 'LOC 640 400 0060 001 000.0 0.8 030.0 000 Template.jpg FastTemplateMatching.py';
PersistentVars.Programs[1].Commands[4].CommandType := DUT_CommandType.OutputCommand;
PersistentVars.Programs[1].Commands[4].CommandString := 'DIG 1 0';
PersistentVars.Programs[1].Commands[5].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[1].Commands[5].CommandString := 'DIR ABS 050 PC1 LIT 00000.00 00000.00 -0010.00 00000.00 00000.00 00000.00';
PersistentVars.Programs[1].Commands[6].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[1].Commands[6].CommandString := 'DIR ABS 050 PC1 VAR VIS 000';
PersistentVars.Programs[1].Commands[7].CommandType := DUT_CommandType.OutputCommand;
PersistentVars.Programs[1].Commands[7].CommandString := 'SRV 1 30.0 360.0';
PersistentVars.Programs[1].Commands[8].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[1].Commands[8].CommandString := 'LIN REL 050 TCS LIT 00000.00 00000.00 00010.00 00000.00 00000.00 00000.00';
PersistentVars.Programs[1].Commands[9].CommandType := DUT_CommandType.OutputCommand;
PersistentVars.Programs[1].Commands[9].CommandString := 'SRV 1 0.0 360.0';
PersistentVars.Programs[1].Commands[10].CommandType := DUT_CommandType.PauseCommand;
PersistentVars.Programs[1].Commands[10].CommandString := 'T#1s';
PersistentVars.Programs[1].Commands[11].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[1].Commands[11].CommandString := 'LIN REL 050 TCS LIT 00000.00 00000.00 -0010.00 00000.00 00000.00 00000.00';
PersistentVars.Programs[1].Commands[12].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[1].Commands[12].CommandString := 'DIR ABS 050 PC1 LIT 00000.00 00000.00 -0050.00 00000.00 00000.00 00000.00';
PersistentVars.Programs[1].Commands[13].CommandType := DUT_CommandType.OutputCommand;
PersistentVars.Programs[1].Commands[13].CommandString := 'SRV 1 30.0 360.0';

//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[2].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[2].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[2].ProgramName := 'PCS1 Corners';
PersistentVars.Programs[2].Commands[0].CommandType := DUT_CommandType.VarSetCommand;
PersistentVars.Programs[2].Commands[0].CommandString := 'STO 0046 +0000.00 +0000.00 +0000.00 +0090.00 +0000.00 +0000.00';
PersistentVars.Programs[2].Commands[1].CommandType := DUT_CommandType.VarSetCommand;
PersistentVars.Programs[2].Commands[1].CommandString := 'STO 0048 +0283.23 -0066.77 +0195.00 -0127.52 +0179.00 +0102.00';
PersistentVars.Programs[2].Commands[2].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[2].Commands[2].CommandString := 'DIR ABS 050 PC1 LIT 0 0 0 0 0 0';
PersistentVars.Programs[2].Commands[3].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[2].Commands[3].CommandString := 'LIN REL 100 TCS LIT 0.0 200.0 0.0 0.0 0.0 0.0';
PersistentVars.Programs[2].Commands[4].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[2].Commands[4].CommandString := 'LIN REL 100 TCS LIT 00125.00 00000.00 00000.00 00000.00 00000.00 00000.00';
PersistentVars.Programs[2].Commands[5].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[2].Commands[5].CommandString := 'LIN REL 100 TCS LIT 00000.00 -0200.00 00000.00 00000.00 00000.00 00000.00';
PersistentVars.Programs[2].Commands[6].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[2].Commands[6].CommandString := 'LIN REL 100 TCS LIT -0125.00 00000.00 00000.00 00000.00 00000.00 00000.00';
PersistentVars.Programs[2].Commands[7].CommandType := DUT_CommandType.MoveCommand;
PersistentVars.Programs[2].Commands[7].CommandString := 'DIR ABS 050 ACS LIT +00 +30 -30 +00 +30 +00';

//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[3].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[3].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[3].ProgramName := 'Cnc Validation';
PersistentVars.Programs[3].Commands[0].CommandType := DUT_CommandType.CncCommand;
PersistentVars.Programs[3].Commands[0].CommandString := 'CNC_FromFile.cnc XYZ VAR STO 45';
PersistentVars.Programs[3].Commands[1].CommandType := DUT_CommandType.CncCommand;
PersistentVars.Programs[3].Commands[1].CommandString := 'CNC_FromFile.cnc XYZ LIT +0300.00 +0000.00 -0300.00 +0000.00 +0000.00 +0000.00';

//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[4].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[4].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[4].ProgramName := 'Vision Validation';
PersistentVars.Programs[4].Commands[0].CommandType := DUT_CommandType.VisionCommand;
PersistentVars.Programs[4].Commands[0].CommandString := 'LOC 640 400 60 1 0.0 0.8 30.0 10 Template.jpg FastTemplateMatching.py';
PersistentVars.Programs[4].Commands[1].CommandType := DUT_CommandType.VisionCommand;
PersistentVars.Programs[4].Commands[1].CommandString := 'LOC 640 400 60 1 0.0 0.8 30.0 4 strippers2.jpg FastTemplateMatching.py';

//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[5].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[5].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[5].ProgramName := 'VarSet Validation';
PersistentVars.Programs[5].Commands[0].CommandType := DUT_CommandType.VarSetCommand;
PersistentVars.Programs[5].Commands[0].CommandString := 'STO 1 6.0 5.0 4.0 3.0 2.0 1.0 ';
PersistentVars.Programs[5].Commands[1].CommandType := DUT_CommandType.VarSetCommand;
PersistentVars.Programs[5].Commands[1].CommandString := 'VIS 2 1 2 3 4 5 6';
PersistentVars.Programs[5].Commands[2].CommandType := DUT_CommandType.VarSetCommand;
PersistentVars.Programs[5].Commands[2].CommandString := 'FLG 3 1';


//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[6].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[6].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[6].ProgramName := 'Logic Validation';
PersistentVars.Programs[6].Commands[0].CommandType := DUT_CommandType.LogicCommand;
PersistentVars.Programs[6].Commands[0].CommandString := 'IF INPUT 1 EQU 1 THEN OUTPUT 1 1 ELSE OUTPUT 1 0';
PersistentVars.Programs[6].Commands[1].CommandType := DUT_CommandType.LogicCommand;
PersistentVars.Programs[6].Commands[1].CommandString := 'IF INPUT 1 EQU 1 THEN CNTUP 1 ELSE CNTUP 2';
PersistentVars.Programs[6].Commands[2].CommandType := DUT_CommandType.LogicCommand;
PersistentVars.Programs[6].Commands[2].CommandString := 'IF COUNTER 2 GRE 10 THEN NOP ELSE JUMP 0';

//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[11].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[11].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[11].ProgramName := 'Make Me an Egg, Please';
PersistentVars.Programs[11].Commands[0].CommandType := DUT_CommandType.Disabled;
PersistentVars.Programs[11].Commands[0].CommandString := '';

//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[12].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[12].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[12].ProgramName := 'Egg Pick Routine';
PersistentVars.Programs[12].Commands[0].CommandType := DUT_CommandType.Disabled;
PersistentVars.Programs[12].Commands[0].CommandString := '';

//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[13].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[13].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[13].ProgramName := 'Egg Crack Routine';
PersistentVars.Programs[13].Commands[0].CommandType := DUT_CommandType.Disabled;
PersistentVars.Programs[13].Commands[0].CommandString := '';

//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[14].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[14].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[14].ProgramName := 'Egg Flip Routine';
PersistentVars.Programs[14].Commands[0].CommandType := DUT_CommandType.Disabled;
PersistentVars.Programs[14].Commands[0].CommandString := '';

//
FOR _i := GVL.PROG_CMDS_ARR_BEG TO GVL.PROG_CMDS_ARR_END BY 1 DO
	PersistentVars.Programs[15].Commands[_i].CommandType := DUT_CommandType.Disabled;
	PersistentVars.Programs[15].Commands[_i].CommandString := '';
END_FOR
PersistentVars.Programs[15].ProgramName := 'Egg Place Routine';
PersistentVars.Programs[15].Commands[0].CommandType := DUT_CommandType.Disabled;
PersistentVars.Programs[15].Commands[0].CommandString := '';]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Init" Id="{229ed790-05b4-4c75-a8a2-65170cb5046e}">
      <Declaration><![CDATA[METHOD M_Init : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// check if arfbot has been initialized
IF NOT PersistentVars.Flags[GVL.INIT_POS_IDX].Value THEN
	// poses
	PersistentVars.Flags[GVL.HOM_TO_POSE_IDX].Value := FALSE;
	PersistentVars.StoredPositions[GVL.POSE_1_IDX].Position.X := 0.0;
	PersistentVars.StoredPositions[GVL.POSE_1_IDX].Position.Y := -15.0;
	PersistentVars.StoredPositions[GVL.POSE_1_IDX].Position.Z := 115.0;
	PersistentVars.StoredPositions[GVL.POSE_1_IDX].Position.A := 0.0;
	PersistentVars.StoredPositions[GVL.POSE_1_IDX].Position.B := 30.0;
	PersistentVars.StoredPositions[GVL.POSE_1_IDX].Position.C := 0.0;
	
	PersistentVars.StoredPositions[GVL.POSE_2_IDX].Position.X := 0.0;
	PersistentVars.StoredPositions[GVL.POSE_2_IDX].Position.Y := -15.0;
	PersistentVars.StoredPositions[GVL.POSE_2_IDX].Position.Z := 115.0;
	PersistentVars.StoredPositions[GVL.POSE_2_IDX].Position.A := 0.0;
	PersistentVars.StoredPositions[GVL.POSE_2_IDX].Position.B := -30.0;
	PersistentVars.StoredPositions[GVL.POSE_2_IDX].Position.C := 0.0;
		 
	// decoder
	PersistentVars.StoredPositions[GVL.DEC_START_POS].Position.X := 300.0; // TODO need to verify all 6 of these
	PersistentVars.StoredPositions[GVL.DEC_START_POS].Position.Y := 0.0;
	PersistentVars.StoredPositions[GVL.DEC_START_POS].Position.Z := -400.0;
	PersistentVars.StoredPositions[GVL.DEC_START_POS].Position.A := 0.0;
	PersistentVars.StoredPositions[GVL.DEC_START_POS].Position.B := 0.0;
	PersistentVars.StoredPositions[GVL.DEC_START_POS].Position.C := 0.0;
	
	// set homing offsets
	PersistentVars.StoredPositions[GVL.HOM_POS_IDX].Position.X := 166; // J1 initial home offset
	PersistentVars.StoredPositions[GVL.HOM_POS_IDX].Position.Y := -35.3; // J2 initial home offset
	PersistentVars.StoredPositions[GVL.HOM_POS_IDX].Position.Z := 145; // J3 initial home offset
	PersistentVars.StoredPositions[GVL.HOM_POS_IDX].Position.A := -166; // J4 initial home offset
	PersistentVars.StoredPositions[GVL.HOM_POS_IDX].Position.B := -99.2; // J5 initial home offset
	PersistentVars.StoredPositions[GVL.HOM_POS_IDX].Position.C := 178; // J6 initial home offset
	
	// set speeds
	PersistentVars.StoredPositions[GVL.SPEEDS_IDX].Position.X := 100.0; // max velocity
	PersistentVars.StoredPositions[GVL.SPEEDS_IDX].Position.Y := 1000.0; // max accel/decel
	PersistentVars.StoredPositions[GVL.SPEEDS_IDX].Position.Z := 1000.0; // max jerk
	PersistentVars.StoredPositions[GVL.SPEEDS_IDX].Position.A := 1.0; // velocity factor
	PersistentVars.StoredPositions[GVL.SPEEDS_IDX].Position.B := 0.05; // accel/decel factor
	PersistentVars.StoredPositions[GVL.SPEEDS_IDX].Position.C := 1.0; // jerk factor
	
	//
	M_BuildTests();
		 
	// indicate initialized
	PersistentVars.Flags[GVL.INIT_POS_IDX].Value := TRUE;
END_IF

//
PersistentVars.StoredPositions[GVL.SPEEDS_IDX].Comment := 'vel, acc, jerk, vel fact, acc fact, jerk fact';
PersistentVars.StoredPositions[GVL.HOM_POS_IDX].Comment := 'Home Offsets J1, J2, J3, J4, J5, J6';
PersistentVars.StoredPositions[GVL.DEC_START_POS].Comment := 'NC Decoder Start Position';
PersistentVars.StoredPositions[GVL.TCP_POS_IDX].Comment := 'TCP Offset';
PersistentVars.StoredPositions[GVL.UC2_POS_IDX].Comment := 'UCS 2 Offset';
PersistentVars.StoredPositions[GVL.UC1_POS_IDX].Comment := 'UCS 1 Offset';
PersistentVars.StoredPositions[GVL.MCS_POS_IDX].Comment := 'MCS Offset';

//	 
PersistentVars.StoredPositions[GVL.POSE_1_IDX].Comment := 'Pose 1 coordinates';
PersistentVars.StoredPositions[GVL.POSE_2_IDX].Comment := 'Pose 2 coordinates';
PersistentVars.StoredPositions[GVL.POSE_3_IDX].Comment := 'Pose 3 coordinates';
PersistentVars.StoredPositions[GVL.POSE_4_IDX].Comment := 'Pose 4 coordinates';
PersistentVars.StoredPositions[GVL.POSE_5_IDX].Comment := 'Pose 5 coordinates';

//
PersistentVars.Flags[GVL.HOM_TO_POSE_IDX].Comment := 'Finish home at Pose';

//
PersistentVars.Flags[GVL.HOME_COMPLETE].Comment := 'Axes are homed';
PersistentVars.Flags[GVL.HOME_COMPLETE].Value := FALSE;

//
PersistentVars.Flags[GVL.INIT_POS_IDX].Comment := 'Variables are Intitialized';
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>